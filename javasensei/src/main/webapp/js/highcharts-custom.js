/*
 Highcharts 4.0.4 JS v/Highstock 2.0.4 (2014-09-02)
 (c) 2009-2014 Torstein Honsi
 License: www.highcharts.com/license
 */
(function(){function y(a, b){var c; a || (a = {}); for (c in b)a[c] = b[c]; return a}function D(){var a, b = arguments, c, d = {}, e = function(a, b){var c, d; "object" !== typeof a && (a = {}); for (d in b)b.hasOwnProperty(d) && ((c = b[d]) && "object" === typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "renderTo" !== d && "number" !== typeof c.nodeType?a[d] = e(a[d] || {}, c):a[d] = b[d]); return a}; !0 === b[0] && (d = b[1], b = Array.prototype.slice.call(b, 2)); c = b.length; for (a = 0; a < c; a++)d = e(d, b[a]); return d}function E(a, b){return parseInt(a,
        b || 10)}function ka(a){return"string" === typeof a}function ca(a){return a && "object" === typeof a}function va(a){return"[object Array]" === Object.prototype.toString.call(a)}function da(a){return"number" === typeof a}function Ya(a){return L.log(a) / L.LN10}function ga(a){return L.pow(10, a)}function wa(a, b){for (var c = a.length; c--; )if (a[c] === b){a.splice(c, 1); break}}function v(a){return a !== w && null !== a}function G(a, b, c){var d, e; if (ka(b))v(c)?a.setAttribute(b, c):a && a.getAttribute && (e = a.getAttribute(b)); else if (v(b) &&
        ca(b))for (d in b)a.setAttribute(d, b[d]); return e}function Z(a){return va(a)?a:[a]}function r(){var a = arguments, b, c, d = a.length; for (b = 0; b < d; b++)if (c = a[b], c !== w && null !== c)return c}function S(a, b){la && !V && b && b.opacity !== w && (b.filter = "alpha(opacity=" + 100 * b.opacity + ")"); y(a.style, b)}function pa(a, b, c, d, e){a = C.createElement(a); b && y(a, b); e && S(a, {padding:0, border:"none", margin:0}); c && S(a, c); d && d.appendChild(a); return a}function Za(a, b){var c = function(){return w}; c.prototype = new a; y(c.prototype, b); return c}
function ha(a, b, c, d){var e = M.numberFormat, f = F.lang, g = + a || 0, h = - 1 === b?(g.toString().split(".")[1] || "").length:isNaN(b = Q(b))?2:b, k = void 0 === c?f.decimalPoint:c, f = void 0 === d?f.thousandsSep:d, l = 0 > g?"-":"", m = String(E(g = Q(g).toFixed(h))), n = 3 < m.length?m.length % 3:0; return e !== ha?e(a, b, c, d):l + (n?m.substr(0, n) + f:"") + m.substr(n).replace(/(\d{3})(?=\d)/g, "$1" + f) + (h?k + Q(g - m).toFixed(h).slice(2):"")}function ma(a, b){return Array((b || 2) + 1 - String(a).length).join(0) + a}function H(a, b, c){var d = a[b]; a[b] = function(){var a =
        Array.prototype.slice.call(arguments); a.unshift(d); return c.apply(this, a)}}function xa(a, b){for (var c = "{", d = !1, e, f, g, h, k, l = []; - 1 !== (c = a.indexOf(c)); ){e = a.slice(0, c); if (d){f = e.split(":"); g = f.shift().split("."); k = g.length; e = b; for (h = 0; h < k; h++)e = e[g[h]]; f.length && (f = f.join(":"), g = /\.([0-9])/, h = F.lang, k = void 0, /f$/.test(f)?(k = (k = f.match(g))?k[1]: - 1, null !== e && (e = ha(e, k, h.decimalPoint, - 1 < f.indexOf(",")?h.thousandsSep:""))):e = Ia(f, e))}l.push(e); a = a.slice(c + 1); c = (d = !d)?"}":"{"}l.push(a); return l.join("")}
function zb(a, b, c, d){var e; c = r(c, 1); e = a / c; b || (b = [1, 2, 2.5, 5, 10], !1 === d && (1 === c?b = [1, 2, 5, 10]:.1 >= c && (b = [1 / c]))); for (d = 0; d < b.length && !(a = b[d], e <= (b[d] + (b[d + 1] || b[d])) / 2); d++); return a * c}function $a(a, b){var c = a.length, d, e; for (e = 0; e < c; e++)a[e].ss_i = e; a.sort(function(a, c){d = b(a, c); return 0 === d?a.ss_i - c.ss_i:d}); for (e = 0; e < c; e++)delete a[e].ss_i}function Ja(a){for (var b = a.length, c = a[0]; b--; )a[b] < c && (c = a[b]); return c}function ya(a){for (var b = a.length, c = a[0]; b--; )a[b] > c && (c = a[b]); return c}function Ka(a, b){for (var c in a)a[c] &&
        a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c]}function La(a){Ma || (Ma = pa("div")); a && Ma.appendChild(a); Ma.innerHTML = ""}function ea(a){return parseFloat(a.toPrecision(14))}function gb(){var a = F.global.useUTC, b = a?"getUTC":"get"; Na = F.global.Date || window.Date; hb = 6E4 * (a && F.global.timezoneOffset || 0); ib = b + "Minutes"; jb = b + "Hours"; kb = b + "Day"; lb = b + "Date"; mb = b + "Month"; nb = b + "FullYear"}function N(){}function na(a, b, c, d){this.axis = a; this.pos = b; this.type = c || ""; this.isNew = !0; c || d || this.addLabel()}function za(){this.init.apply(this,
        arguments)}function Oa(){this.init.apply(this, arguments)}function ob(a, b, c){this.init.call(this, a, b, c)}var w, C = document, I = window, L = Math, A = L.round, W = L.floor, qa = L.ceil, x = L.max, O = L.min, Q = L.abs, Aa = L.cos, Pa = L.sin, pb = L.PI, qb = 2 * pb / 360, ia = navigator.userAgent, Ab = I.opera, la = /msie/i.test(ia) && !Ab, Bb = /AppleWebKit/.test(ia), Qa = /Firefox/.test(ia), rb = /(Mobile|Android|Windows Phone)/.test(ia), V = !!C.createElementNS && !!C.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, Cb = Qa && 4 > parseInt(ia.split("Firefox/")[1],
        10), aa = !V && !la && !!C.createElement("canvas").getContext, Ba, sb = {}, ab = 0, Ma, F, Ia, ba, bb, ra, X, Ca = function(){return w}, T = [], Da = 0, Db = /^[0-9]+$/, Na, hb, ib, jb, kb, lb, mb, nb, K = {}, M; I.Highcharts?X(16, !0):M = I.Highcharts = {}; Ia = function(a, b, c){if (!v(b) || isNaN(b))return"Invalid date"; a = r(a, "%Y-%m-%d %H:%M:%S"); var d = new Na(b - hb), e, f = d[jb](), g = d[kb](), h = d[lb](), k = d[mb](), l = d[nb](), m = F.lang, n = m.weekdays, d = y({a:n[g].substr(0, 3), A:n[g], d:ma(h), e:h, b:m.shortMonths[k], B:m.months[k], m:ma(k + 1), y:l.toString().substr(2, 2), Y:l,
        H:ma(f), I:ma(f % 12 || 12), l:f % 12 || 12, M:ma(d[ib]()), p:12 > f?"AM":"PM", P:12 > f?"am":"pm", S:ma(d.getSeconds()), L:ma(A(b % 1E3), 3)}, M.dateFormats); for (e in d)for (; - 1 !== a.indexOf("%" + e); )a = a.replace("%" + e, "function" === typeof d[e]?d[e](b):d[e]); return c?a.substr(0, 1).toUpperCase() + a.substr(1):a}; X = function(a, b){var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a; if (b)throw c; I.console && console.log(c)}; ra = {millisecond:1, second:1E3, minute:6E4, hour:36E5, day:864E5, week:6048E5, month:26784E5, year:31556952E3};
        bb = {init:function(a, b, c){b = b || ""; var d = a.shift, e = - 1 < b.indexOf("C"), f = e?7:3, g; b = b.split(" "); c = [].concat(c); var h, k, l = function(a){for (g = a.length; g--; )"M" === a[g] && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2])}; e && (l(b), l(c)); a.isArea && (h = b.splice(b.length - 6, 6), k = c.splice(c.length - 6, 6)); if (d <= c.length / f && b.length === c.length)for (; d--; )c = [].concat(c).splice(0, f).concat(c); a.shift = 0; if (b.length)for (a = c.length; b.length < a; )d = [].concat(b).splice(b.length - f, f), e && (d[f - 6] = d[f - 2], d[f - 5] = d[f - 1]), b = b.concat(d); h &&
                (b = b.concat(h), c = c.concat(k)); return[b, c]}, step:function(a, b, c, d){var e = [], f = a.length; if (1 === c)e = d; else if (f === b.length && 1 > c)for (; f--; )d = parseFloat(a[f]), e[f] = isNaN(d)?a[f]:c * parseFloat(b[f] - d) + d; else e = b; return e}}; (function(a){I.HighchartsAdapter = I.HighchartsAdapter || a && {init:function(b){var c = a.fx; a.extend(a.easing, {easeOutQuad:function(a, b, c, g, h){return - g * (b /= h) * (b - 2) + c}}); a.each(["cur", "_default", "width", "height", "opacity"], function(b, e){var f = c.step, g; "cur" === e?f = c.prototype:"_default" === e &&
        a.Tween && (f = a.Tween.propHooks[e], e = "set"); (g = f[e]) && (f[e] = function(a){var c; a = b?a:this; if ("align" !== a.prop)return c = a.elem, c.attr?c.attr(a.prop, "cur" === e?w:a.now):g.apply(this, arguments)})}); H(a.cssHooks.opacity, "get", function(a, b, c){return b.attr?b.opacity || 0:a.call(this, b, c)}); this.addAnimSetter("d", function(a){var c = a.elem, f; a.started || (f = b.init(c, c.d, c.toD), a.start = f[0], a.end = f[1], a.started = !0); c.attr("d", b.step(a.start, a.end, a.pos, c.toD))}); this.each = Array.prototype.forEach?function(a, b){return Array.prototype.forEach.call(a,
        b)}:function(a, b){var c, g = a.length; for (c = 0; c < g; c++)if (!1 === b.call(a[c], a[c], c, a))return c}; a.fn.highcharts = function(){var a = "Chart", b = arguments, c, g; this[0] && (ka(b[0]) && (a = b[0], b = Array.prototype.slice.call(b, 1)), c = b[0], c !== w && (c.chart = c.chart || {}, c.chart.renderTo = this[0], new M[a](c, b[1]), g = this), c === w && (g = T[G(this[0], "data-highcharts-chart")])); return g}}, addAnimSetter:function(b, c){a.Tween?a.Tween.propHooks[b] = {set:c}:a.fx.step[b] = c}, getScript:a.getScript, inArray:a.inArray, adapterRun:function(b, c){return a(b)[c]()},
        grep:a.grep, map:function(a, c){for (var d = [], e = 0, f = a.length; e < f; e++)d[e] = c.call(a[e], a[e], e, a); return d}, offset:function(b){return a(b).offset()}, addEvent:function(b, c, d){a(b).bind(c, d)}, removeEvent:function(b, c, d){var e = C.removeEventListener?"removeEventListener":"detachEvent"; C[e] && b && !b[e] && (b[e] = function(){}); a(b).unbind(c, d)}, fireEvent:function(b, c, d, e){var f = a.Event(c), g = "detached" + c, h; !la && d && (delete d.layerX, delete d.layerY, delete d.returnValue); y(f, d); b[c] && (b[g] = b[c], b[c] = null); a.each(["preventDefault",
        "stopPropagation"], function(a, b){var c = f[b]; f[b] = function(){try{c.call(f)} catch (a){"preventDefault" === b && (h = !0)}}}); a(b).trigger(f); b[g] && (b[c] = b[g], b[g] = null); !e || f.isDefaultPrevented() || h || e(f)}, washMouseEvent:function(a){var c = a.originalEvent || a; c.pageX === w && (c.pageX = a.pageX, c.pageY = a.pageY); return c}, animate:function(b, c, d){var e = a(b); b.style || (b.style = {}); c.d && (b.toD = c.d, c.d = 1); e.stop(); c.opacity !== w && b.attr && (c.opacity += "px"); b.hasAnim = 1; e.animate(c, d)}, stop:function(b){b.hasAnim && a(b).stop()}}})(I.jQuery);
        var Ra = I.HighchartsAdapter, Y = Ra || {}; Ra && Ra.init.call(Ra, bb); var Sa = Y.adapterRun, Ta = Y.inArray, t = Y.each, tb = Y.grep, Eb = Y.offset, Ea = Y.map, J = Y.addEvent, P = Y.removeEvent, z = Y.fireEvent, Fb = Y.washMouseEvent, ub = Y.animate, Ua = Y.stop, cb = {enabled:!0, x:0, y:15, style:{color:"#606060", cursor:"default", fontSize:"11px"}}; F = {colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #8085e8 #8d4653 #91e8e1".split(" "), symbols:["circle", "diamond", "square", "triangle", "triangle-down"], lang:{loading:"Loading...", months:"January February March April May June July August September October November December".split(" "),
        shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint:".", numericSymbols:"kMGTPE".split(""), resetZoom:"Reset zoom", resetZoomTitle:"Reset zoom level 1:1", thousandsSep:","}, global:{useUTC:!0, canvasToolsURL:"http://code.highcharts.com@product.cdnpath@//Highstock 2.0.4/modules/canvas-tools.js", VMLRadialGradientURL:"http://code.highcharts.com@product.cdnpath@//Highstock 2.0.4/gfx/vml-radial-gradient.png"},
        chart:{borderColor:"#4572A7", borderRadius:0, defaultSeriesType:"line", ignoreHiddenSeries:!0, spacing:[10, 10, 15, 10], backgroundColor:"#FFFFFF", plotBorderColor:"#C0C0C0", resetZoomButton:{theme:{zIndex:20}, position:{align:"right", x: - 10, y:10}}}, title:{text:"Chart title", align:"center", margin:15, style:{color:"#333333", fontSize:"18px"}}, subtitle:{text:"", align:"center", style:{color:"#555555"}}, plotOptions:{line:{allowPointSelect:!1, showCheckbox:!1, animation:{duration:1E3}, events:{}, lineWidth:2, marker:{lineWidth:0,
        radius:4, lineColor:"#FFFFFF", states:{hover:{enabled:!0, lineWidthPlus:1, radiusPlus:2}, select:{fillColor:"#FFFFFF", lineColor:"#000000", lineWidth:2}}}, point:{events:{}}, dataLabels:D(cb, {align:"center", enabled:!1, formatter:function(){return null === this.y?"":ha(this.y, - 1)}, verticalAlign:"bottom", y:0}), cropThreshold:300, pointRange:0, states:{hover:{lineWidthPlus:1, marker:{}, halo:{size:10, opacity:.25}}, select:{marker:{}}}, stickyTracking:!0, turboThreshold:1E3}}, labels:{style:{position:"absolute", color:"#3E576F"}},
        legend:{enabled:!0, align:"center", layout:"horizontal", labelFormatter:function(){return this.name}, borderColor:"#909090", borderRadius:0, navigation:{activeColor:"#274b6d", inactiveColor:"#CCC"}, shadow:!1, itemStyle:{color:"#333333", fontSize:"12px", fontWeight:"bold"}, itemHoverStyle:{color:"#000"}, itemHiddenStyle:{color:"#CCC"}, itemCheckboxStyle:{position:"absolute", width:"13px", height:"13px"}, symbolPadding:5, verticalAlign:"bottom", x:0, y:0, title:{style:{fontWeight:"bold"}}}, loading:{labelStyle:{fontWeight:"bold",
        position:"relative", top:"45%"}, style:{position:"absolute", backgroundColor:"white", opacity:.5, textAlign:"center"}}, tooltip:{enabled:!0, animation:V, backgroundColor:"rgba(249, 249, 249, .85)", borderWidth:1, borderRadius:3, dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L", second:"%A, %b %e, %H:%M:%S", minute:"%A, %b %e, %H:%M", hour:"%A, %b %e, %H:%M", day:"%A, %b %e, %Y", week:"Week from %A, %b %e, %Y", month:"%B %Y", year:"%Y"}, headerFormat:'<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat:'<span style="color:{series.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>', shadow:!0, snap:rb?25:10, style:{color:"#333333", cursor:"default", fontSize:"12px", padding:"8px", whiteSpace:"nowrap"}}, credits:{enabled:!0, text:"Highcharts.com", href:"http://www.highcharts.com", position:{align:"right", x: - 10, verticalAlign:"bottom", y: - 5}, style:{cursor:"pointer", color:"#909090", fontSize:"9px"}}}; var sa = F.plotOptions, Gb = sa.line; gb(); var Hb = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        Ib = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, Jb = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, oa = function(a){var b = [], c, d; (function(a){a && a.stops?d = Ea(a.stops, function(a){return oa(a[1])}):(c = Hb.exec(a))?b = [E(c[1]), E(c[2]), E(c[3]), parseFloat(c[4], 10)]:(c = Ib.exec(a))?b = [E(c[1], 16), E(c[2], 16), E(c[3], 16), 1]:(c = Jb.exec(a)) && (b = [E(c[1]), E(c[2]), E(c[3]), 1])})(a); return{get:function(c){var f; d?(f = D(a), f.stops = [].concat(f.stops), t(d, function(a, b){f.stops[b] = [f.stops[b][0], a.get(c)]})):
                f = b && !isNaN(b[0])?"rgb" === c?"rgb(" + b[0] + "," + b[1] + "," + b[2] + ")":"a" === c?b[3]:"rgba(" + b.join(",") + ")":a; return f}, brighten:function(a){if (d)t(d, function(b){b.brighten(a)}); else if (da(a) && 0 !== a){var c; for (c = 0; 3 > c; c++)b[c] += E(255 * a), 0 > b[c] && (b[c] = 0), 255 < b[c] && (b[c] = 255)}return this}, rgba:b, setOpacity:function(a){b[3] = a; return this}}}; N.prototype = {opacity:1, textProps:"fontSize fontWeight fontFamily color lineHeight width textDecoration textShadow HcTextStroke".split(" "), init:function(a, b){this.element =
        "span" === b?pa(b):C.createElementNS("http://www.w3.org/2000/svg", b); this.renderer = a}, animate:function(a, b, c){b = r(b, ba, !0); Ua(this); b?(b = D(b, {}), c && (b.complete = c), ub(this, a, b)):(this.attr(a), c && c()); return this}, colorGradient:function(a, b, c){var d = this.renderer, e, f, g, h, k, l, m, n, p, q, u = []; a.linearGradient?f = "linearGradient":a.radialGradient && (f = "radialGradient"); if (f){g = a[f]; h = d.gradients; l = a.stops; p = c.radialReference; va(g) && (a[f] = g = {x1:g[0], y1:g[1], x2:g[2], y2:g[3], gradientUnits:"userSpaceOnUse"}); "radialGradient" ===
        f && p && !v(g.gradientUnits) && (g = D(g, {cx:p[0] - p[2] / 2 + g.cx * p[2], cy:p[1] - p[2] / 2 + g.cy * p[2], r:g.r * p[2], gradientUnits:"userSpaceOnUse"})); for (q in g)"id" !== q && u.push(q, g[q]); for (q in l)u.push(l[q]); u = u.join(","); h[u]?a = h[u].attr("id"):(g.id = a = "highcharts-" + ab++, h[u] = k = d.createElement(f).attr(g).add(d.defs), k.stops = [], t(l, function(a){0 === a[1].indexOf("rgba")?(e = oa(a[1]), m = e.get("rgb"), n = e.get("a")):(m = a[1], n = 1); a = d.createElement("stop").attr({offset:a[0], "stop-color":m, "stop-opacity":n}).add(k); k.stops.push(a)}));
        c.setAttribute(b, "url(" + d.url + "#" + a + ")")}}, attr:function(a, b){var c, d, e = this.element, f, g = this, h; "string" === typeof a && b !== w && (c = a, a = {}, a[c] = b); if ("string" === typeof a)g = (this[a + "Getter"] || this._defaultGetter).call(this, a, e); else{for (c in a)d = a[c], h = !1, this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(c) && (f || (this.symbolAttr(a), f = !0), h = !0), !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0), h || (this[c + "Setter"] || this._defaultSetter).call(this, d, c, e), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) &&
        this.updateShadows(c, d); this.doTransform && (this.updateTransform(), this.doTransform = !1)}return g}, updateShadows:function(a, b){for (var c = this.shadows, d = c.length; d--; )c[d].setAttribute(a, "height" === a?x(b - (c[d].cutHeight || 0), 0):"d" === a?this.d:b)}, addClass:function(a){var b = this.element, c = G(b, "class") || ""; - 1 === c.indexOf(a) && G(b, "class", c + " " + a); return this}, symbolAttr:function(a){var b = this; t("x y r start end width height innerR anchorX anchorY".split(" "), function(c){b[c] = r(a[c], b[c])}); b.attr({d:b.renderer.symbols[b.symbolName](b.x,
        b.y, b.width, b.height, b)})}, clip:function(a){return this.attr("clip-path", a?"url(" + this.renderer.url + "#" + a.id + ")":"none")}, crisp:function(a){var b, c = {}, d, e = a.strokeWidth || this.strokeWidth || 0; d = A(e) % 2 / 2; a.x = W(a.x || this.x || 0) + d; a.y = W(a.y || this.y || 0) + d; a.width = W((a.width || this.width || 0) - 2 * d); a.height = W((a.height || this.height || 0) - 2 * d); a.strokeWidth = e; for (b in a)this[b] !== a[b] && (this[b] = c[b] = a[b]); return c}, css:function(a){var b = this.styles, c = {}, d = this.element, e, f, g = ""; e = !b; a && a.color && (a.fill = a.color);
        if (b)for (f in a)a[f] !== b[f] && (c[f] = a[f], e = !0); if (e){e = this.textWidth = a && a.width && "text" === d.nodeName.toLowerCase() && E(a.width); b && (a = y(b, c)); this.styles = a; e && (aa || !V && this.renderer.forExport) && delete a.width; if (la && !V)S(this.element, a); else{b = function(a, b){return"-" + b.toLowerCase()}; for (f in a)g += f.replace(/([A-Z])/g, b) + ":" + a[f] + ";"; G(d, "style", g)}e && this.added && this.renderer.buildText(this)}return this}, on:function(a, b){var c = this, d = c.element; Ba && "click" === a?(d.ontouchstart = function(a){c.touchEventFired =
        Na.now(); a.preventDefault(); b.call(d, a)}, d.onclick = function(a){( - 1 === ia.indexOf("Android") || 1100 < Na.now() - (c.touchEventFired || 0)) && b.call(d, a)}):d["on" + a] = b; return this}, setRadialReference:function(a){this.element.radialReference = a; return this}, translate:function(a, b){return this.attr({translateX:a, translateY:b})}, invert:function(){this.inverted = !0; this.updateTransform(); return this}, updateTransform:function(){var a = this.translateX || 0, b = this.translateY || 0, c = this.scaleX, d = this.scaleY, e = this.inverted,
        f = this.rotation, g = this.element; e && (a += this.attr("width"), b += this.attr("height")); a = ["translate(" + a + "," + b + ")"]; e?a.push("rotate(90) scale(-1,1)"):f && a.push("rotate(" + f + " " + (g.getAttribute("x") || 0) + " " + (g.getAttribute("y") || 0) + ")"); (v(c) || v(d)) && a.push("scale(" + r(c, 1) + " " + r(d, 1) + ")"); a.length && g.setAttribute("transform", a.join(" "))}, toFront:function(){var a = this.element; a.parentNode.appendChild(a); return this}, align:function(a, b, c){var d, e, f, g, h = {}; e = this.renderer; f = e.alignedObjects; if (a){if (this.alignOptions =
        a, this.alignByTranslate = b, !c || ka(c))this.alignTo = d = c || "renderer", wa(f, this), f.push(this), c = null} else a = this.alignOptions, b = this.alignByTranslate, d = this.alignTo; c = r(c, e[d], e); d = a.align; e = a.verticalAlign; f = (c.x || 0) + (a.x || 0); g = (c.y || 0) + (a.y || 0); if ("right" === d || "center" === d)f += (c.width - (a.width || 0)) / {right:1, center:2}[d]; h[b?"translateX":"x"] = A(f); if ("bottom" === e || "middle" === e)g += (c.height - (a.height || 0)) / ({bottom:1, middle:2}[e] || 1); h[b?"translateY":"y"] = A(g); this[this.placed?"animate":"attr"](h); this.placed =
        !0; this.alignAttr = h; return this}, getBBox:function(){var a = this.bBox, b = this.renderer, c, d, e = this.rotation; c = this.element; var f = this.styles, g = e * qb; d = this.textStr; var h; if ("" === d || Db.test(d))h = "num." + d.toString().length + (f?"|" + f.fontSize + "|" + f.fontFamily:""); h && (a = b.cache[h]); if (!a){if ("http://www.w3.org/2000/svg" === c.namespaceURI || b.forExport){try{a = c.getBBox?y({}, c.getBBox()):{width:c.offsetWidth, height:c.offsetHeight}} catch (k){}if (!a || 0 > a.width)a = {width:0, height:0}} else a = this.htmlGetBBox(); b.isSVG &&
        (c = a.width, d = a.height, la && f && "11px" === f.fontSize && "16.9" === d.toPrecision(3) && (a.height = d = 14), e && (a.width = Q(d * Pa(g)) + Q(c * Aa(g)), a.height = Q(d * Aa(g)) + Q(c * Pa(g)))); this.bBox = a; h && (b.cache[h] = a)}return a}, show:function(a){a && "http://www.w3.org/2000/svg" === this.element.namespaceURI?this.element.removeAttribute("visibility"):this.attr({visibility:a?"inherit":"visible"}); return this}, hide:function(){return this.attr({visibility:"hidden"})}, fadeOut:function(a){var b = this; b.animate({opacity:0}, {duration:a ||
        150, complete:function(){b.attr({y: - 9999})}})}, add:function(a){var b = this.renderer, c = a || b, d = c.element || b.box, e = this.element, f = this.zIndex, g, h; a && (this.parentGroup = a); this.parentInverted = a && a.inverted; void 0 !== this.textStr && b.buildText(this); f && (c.handleZ = !0, f = E(f)); if (c.handleZ)for (a = d.childNodes, g = 0; g < a.length; g++)if (b = a[g], c = G(b, "zIndex"), b !== e && (E(c) > f || !v(f) && v(c))){d.insertBefore(e, b); h = !0; break}h || d.appendChild(e); this.added = !0; if (this.onAdd)this.onAdd(); return this}, safeRemoveChild:function(a){var b =
        a.parentNode; b && b.removeChild(a)}, destroy:function(){var a = this, b = a.element || {}, c = a.shadows, d = a.renderer.isSVG && "SPAN" === b.nodeName && a.parentGroup, e, f; b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null; Ua(a); a.clipPath && (a.clipPath = a.clipPath.destroy()); if (a.stops){for (f = 0; f < a.stops.length; f++)a.stops[f] = a.stops[f].destroy(); a.stops = null}a.safeRemoveChild(b); for (c && t(c, function(b){a.safeRemoveChild(b)}); d && d.div && 0 === d.div.childNodes.length; )b = d.parentGroup, a.safeRemoveChild(d.div), delete d.div,
        d = b; a.alignTo && wa(a.renderer.alignedObjects, a); for (e in a)delete a[e]; return null}, shadow:function(a, b, c){var d = [], e, f, g = this.element, h, k, l, m; if (a){k = r(a.width, 3); l = (a.opacity || .15) / k; m = this.parentInverted?"(-1,-1)":"(" + r(a.offsetX, 1) + ", " + r(a.offsetY, 1) + ")"; for (e = 1; e <= k; e++)f = g.cloneNode(0), h = 2 * k + 1 - 2 * e, G(f, {isShadow:"true", stroke:a.color || "black", "stroke-opacity":l * e, "stroke-width":h, transform:"translate" + m, fill:"none"}), c && (G(f, "height", x(G(f, "height") - h, 0)), f.cutHeight = h), b?b.element.appendChild(f):
        g.parentNode.insertBefore(f, g), d.push(f); this.shadows = d}return this}, xGetter:function(a){"circle" === this.element.nodeName && (a = {x:"cx", y:"cy"}[a] || a); return this._defaultGetter(a)}, _defaultGetter:function(a){a = r(this[a], this.element?this.element.getAttribute(a):null, 0); /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a)); return a}, dSetter:function(a, b, c){a && a.join && (a = a.join(" ")); /(NaN| {2}|^$)/.test(a) && (a = "M 0 0"); c.setAttribute(b, a); this[b] = a}, dashstyleSetter:function(a){var b; if (a = a && a.toLowerCase()){a =
        a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (b = a.length; b--; )a[b] = E(a[b]) * this["stroke-width"]; a = a.join(",").replace("NaN", "none"); this.element.setAttribute("stroke-dasharray", a)}}, alignSetter:function(a){this.element.setAttribute("text-anchor", {left:"start", center:"middle", right:"end"}[a])}, opacitySetter:function(a,
        b, c){this[b] = a; c.setAttribute(b, a)}, titleSetter:function(a){var b = this.element.getElementsByTagName("title")[0]; b || (b = C.createElementNS("http://www.w3.org/2000/svg", "title"), this.element.appendChild(b)); b.textContent = r(a, "").replace(/<[^>]*>/g, "")}, textSetter:function(a){a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this))}, fillSetter:function(a, b, c){"string" === typeof a?c.setAttribute(b, a):a && this.colorGradient(a, b, c)}, zIndexSetter:function(a, b, c){c.setAttribute(b,
        a); this[b] = a}, _defaultSetter:function(a, b, c){c.setAttribute(b, a)}}; N.prototype.yGetter = N.prototype.xGetter; N.prototype.translateXSetter = N.prototype.translateYSetter = N.prototype.rotationSetter = N.prototype.verticalAlignSetter = N.prototype.scaleXSetter = N.prototype.scaleYSetter = function(a, b){this[b] = a; this.doTransform = !0}; N.prototype["stroke-widthSetter"] = N.prototype.strokeSetter = function(a, b, c){this[b] = a; this.stroke && this["stroke-width"]?(this.strokeWidth = this["stroke-width"], N.prototype.fillSetter.call(this,
        this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0):"stroke-width" === b && 0 === a && this.hasStroke && (c.removeAttribute("stroke"), this.hasStroke = !1)}; var Fa = function(){this.init.apply(this, arguments)}; Fa.prototype = {Element:N, init:function(a, b, c, d, e){var f = location, g; d = this.createElement("svg").attr({version:"1.1"}).css(this.getStyle(d)); g = d.element; a.appendChild(g); - 1 === a.innerHTML.indexOf("xmlns") && G(g, "xmlns", "http://www.w3.org/2000/svg"); this.isSVG = !0; this.box =
        g; this.boxWrapper = d; this.alignedObjects = []; this.url = (Qa || Bb) && C.getElementsByTagName("base").length?f.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20"):""; this.createElement("desc").add().element.appendChild(C.createTextNode("Created with Highcharts 4.0.4 /Highstock 2.0.4")); this.defs = this.createElement("defs").add(); this.forExport = e; this.gradients = {}; this.cache = {}; this.setSize(b, c, !1); var h; Qa && a.getBoundingClientRect && (this.subPixelFix = b = function(){S(a, {left:0, top:0}); h =
        a.getBoundingClientRect(); S(a, {left:qa(h.left) - h.left + "px", top:qa(h.top) - h.top + "px"})}, b(), J(I, "resize", b))}, getStyle:function(a){return this.style = y({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize:"12px"}, a)}, isHidden:function(){return!this.boxWrapper.getBBox().width}, destroy:function(){var a = this.defs; this.box = null; this.boxWrapper = this.boxWrapper.destroy(); Ka(this.gradients || {}); this.gradients = null; a && (this.defs = a.destroy()); this.subPixelFix && P(I, "resize",
        this.subPixelFix); return this.alignedObjects = null}, createElement:function(a){var b = new this.Element; b.init(this, a); return b}, draw:function(){}, buildText:function(a){for (var b = a.element, c = this, d = c.forExport, e = r(a.textStr, "").toString(), f = - 1 !== e.indexOf("<"), g = b.childNodes, h, k, l = G(b, "x"), m = a.styles, n = a.textWidth, p = m && m.lineHeight, q = m && m.HcTextStroke, u = g.length, B = function(a){return p?E(p):c.fontMetrics(/(px|em)$/.test(a && a.style.fontSize)?a.style.fontSize:m && m.fontSize || c.style.fontSize || 12, a).h}; u--; )b.removeChild(g[u]);
        f || q || - 1 !== e.indexOf(" ")?(h = /<.*style="([^"]+)".*>/, k = /<.*href="(http[^"]+)".*>/, n && !a.added && this.box.appendChild(b), e = f?e.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g):[e], "" === e[e.length - 1] && e.pop(), t(e, function(e, f){var g, p = 0; e = e.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"); g = e.split("|||"); t(g, function(e){if ("" !== e || 1 === g.length){var q =
{}, u = C.createElementNS("http://www.w3.org/2000/svg", "tspan"), r; h.test(e) && (r = e.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), G(u, "style", r)); k.test(e) && !d && (G(u, "onclick", 'location.href="' + e.match(k)[1] + '"'), S(u, {cursor:"pointer"})); e = (e.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"); if (" " !== e){u.appendChild(C.createTextNode(e)); p?q.dx = 0:f && null !== l && (q.x = l); G(u, q); b.appendChild(u); !p && f && (!V && d && S(u, {display:"block"}), G(u, "dy", B(u))); if (n){e = e.replace(/([^\^])-/g,
        "$1- ").split(" "); for (var q = 1 < g.length || 1 < e.length && "nowrap" !== m.whiteSpace, t, U, w = m.HcHeight, v = [], x = B(u), vb = 1; q && (e.length || v.length); )delete a.bBox, t = a.getBBox(), U = t.width, !V && c.forExport && (U = c.measureSpanWidth(u.firstChild.data, a.styles)), (t = U > n) && 1 !== e.length?(u.removeChild(u.firstChild), v.unshift(e.pop())):(e = v, v = [], e.length && (vb++, w && vb * x > w?(e = ["..."], a.attr("title", a.textStr)):(u = C.createElementNS("http://www.w3.org/2000/svg", "tspan"), G(u, {dy:x, x:l}), r && G(u, "style", r), b.appendChild(u))), U >
        n && (n = U)), e.length && u.appendChild(C.createTextNode(e.join(" ").replace(/- /g, "-")))}p++}}})})):b.appendChild(C.createTextNode(e))}, button:function(a, b, c, d, e, f, g, h, k){var l = this.label(a, b, c, k, null, null, null, null, "button"), m = 0, n, p, q, u, B, r; a = {x1:0, y1:0, x2:0, y2:1}; e = D({"stroke-width":1, stroke:"#CCCCCC", fill:{linearGradient:a, stops:[[0, "#FEFEFE"], [1, "#F6F6F6"]]}, r:2, padding:5, style:{color:"black"}}, e); q = e.style; delete e.style; f = D(e, {stroke:"#68A", fill:{linearGradient:a, stops:[[0, "#FFF"], [1, "#ACF"]]}},
        f); u = f.style; delete f.style; g = D(e, {stroke:"#68A", fill:{linearGradient:a, stops:[[0, "#9BD"], [1, "#CDF"]]}}, g); B = g.style; delete g.style; h = D(e, {style:{color:"#CCC"}}, h); r = h.style; delete h.style; J(l.element, la?"mouseover":"mouseenter", function(){3 !== m && l.attr(f).css(u)}); J(l.element, la?"mouseout":"mouseleave", function(){3 !== m && (n = [e, f, g][m], p = [q, u, B][m], l.attr(n).css(p))}); l.setState = function(a){(l.state = m = a)?2 === a?l.attr(g).css(B):3 === a && l.attr(h).css(r):l.attr(e).css(q)}; return l.on("click", function(){3 !==
        m && d.call(l)}).attr(e).css(y({cursor:"default"}, q))}, crispLine:function(a, b){a[1] === a[4] && (a[1] = a[4] = A(a[1]) - b % 2 / 2); a[2] === a[5] && (a[2] = a[5] = A(a[2]) + b % 2 / 2); return a}, path:function(a){var b = {fill:"none"}; va(a)?b.d = a:ca(a) && y(b, a); return this.createElement("path").attr(b)}, circle:function(a, b, c){a = ca(a)?a:{x:a, y:b, r:c}; b = this.createElement("circle"); b.xSetter = function(a){this.element.setAttribute("cx", a)}; b.ySetter = function(a){this.element.setAttribute("cy", a)}; return b.attr(a)}, arc:function(a, b, c, d,
        e, f){ca(a) && (b = a.y, c = a.r, d = a.innerR, e = a.start, f = a.end, a = a.x); a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {innerR:d || 0, start:e || 0, end:f || 0}); a.r = c; return a}, rect:function(a, b, c, d, e, f){e = ca(a)?a.r:e; var g = this.createElement("rect"); a = ca(a)?a:a === w?{}:{x:a, y:b, width:x(c, 0), height:x(d, 0)}; f !== w && (a.strokeWidth = f, a = g.crisp(a)); e && (a.r = e); g.rSetter = function(a){G(this.element, {rx:a, ry:a})}; return g.attr(a)}, setSize:function(a, b, c){var d = this.alignedObjects, e = d.length; this.width = a; this.height = b; for (this.boxWrapper[r(c,
        !0)?"animate":"attr"]({width:a, height:b}); e--; )d[e].align()}, g:function(a){var b = this.createElement("g"); return v(a)?b.attr({"class":"highcharts-" + a}):b}, image:function(a, b, c, d, e){var f = {preserveAspectRatio:"none"}; 1 < arguments.length && y(f, {x:b, y:c, width:d, height:e}); f = this.createElement("image").attr(f); f.element.setAttributeNS?f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a):f.element.setAttribute("hc-svg-href", a); return f}, symbol:function(a, b, c, d, e, f){var g, h = this.symbols[a], h =
        h && h(A(b), A(c), d, e, f), k = /^url\((.*?)\)$/, l, m; h?(g = this.path(h), y(g, {symbolName:a, x:b, y:c, width:d, height:e}), f && y(g, f)):k.test(a) && (m = function(a, b){a.element && (a.attr({width:b[0], height:b[1]}), a.alignByTranslate || a.translate(A((d - b[0]) / 2), A((e - b[1]) / 2)))}, l = a.match(k)[1], a = sb[l] || f && f.width && f.height && [f.width, f.height], g = this.image(l).attr({x:b, y:c}), g.isImg = !0, a?m(g, a):(g.attr({width:0, height:0}), pa("img", {onload:function(){m(g, sb[l] = [this.width, this.height])}, src:l}))); return g}, symbols:{circle:function(a,
        b, c, d){var e = .166 * c; return["M", a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"]}, square:function(a, b, c, d){return["M", a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"]}, triangle:function(a, b, c, d){return["M", a + c / 2, b, "L", a + c, b + d, a, b + d, "Z"]}, "triangle-down":function(a, b, c, d){return["M", a, b, "L", a + c, b, a + c / 2, b + d, "Z"]}, diamond:function(a, b, c, d){return["M", a + c / 2, b, "L", a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"]}, arc:function(a, b, c, d, e){var f = e.start; c = e.r || c || d; var g = e.end - .001; d = e.innerR; var h = e.open, k = Aa(f), l =
        Pa(f), m = Aa(g), g = Pa(g); e = e.end - f < pb?0:1; return["M", a + c * k, b + c * l, "A", c, c, 0, e, 1, a + c * m, b + c * g, h?"M":"L", a + d * m, b + d * g, "A", d, d, 0, e, 0, a + d * k, b + d * l, h?"":"Z"]}, callout:function(a, b, c, d, e){var f = O(e && e.r || 0, c, d), g = f + 6, h = e && e.anchorX, k = e && e.anchorY; e = A(e.strokeWidth || 0) % 2 / 2; a += e; b += e; e = ["M", a + f, b, "L", a + c - f, b, "C", a + c, b, a + c, b, a + c, b + f, "L", a + c, b + d - f, "C", a + c, b + d, a + c, b + d, a + c - f, b + d, "L", a + f, b + d, "C", a, b + d, a, b + d, a, b + d - f, "L", a, b + f, "C", a, b, a, b, a + f, b]; h && h > c && k > b + g && k < b + d - g?e.splice(13, 3, "L", a + c, k - 6, a + c + 6, k, a + c, k + 6, a + c, b + d -
        f):h && 0 > h && k > b + g && k < b + d - g?e.splice(33, 3, "L", a, k + 6, a - 6, k, a, k - 6, a, b + f):k && k > d && h > a + g && h < a + c - g?e.splice(23, 3, "L", h + 6, b + d, h, b + d + 6, h - 6, b + d, a + f, b + d):k && 0 > k && h > a + g && h < a + c - g && e.splice(3, 3, "L", h - 6, b, h, b - 6, h + 6, b, c - f, b); return e}}, clipRect:function(a, b, c, d){var e = "highcharts-" + ab++, f = this.createElement("clipPath").attr({id:e}).add(this.defs); a = this.rect(a, b, c, d, 0).add(f); a.id = e; a.clipPath = f; return a}, text:function(a, b, c, d){var e = aa || !V && this.forExport, f = {}; if (d && !this.forExport)return this.html(a, b, c); f.x = Math.round(b ||
        0); c && (f.y = Math.round(c)); if (a || 0 === a)f.text = a; a = this.createElement("text").attr(f); e && a.css({position:"absolute"}); d || (a.xSetter = function(a, b, c){var d = c.getElementsByTagName("tspan"), e, f = c.getAttribute(b), p; for (p = 0; p < d.length; p++)e = d[p], e.getAttribute(b) === f && e.setAttribute(b, a); c.setAttribute(b, a)}); return a}, fontMetrics:function(a, b){a = a || this.style.fontSize; b && I.getComputedStyle && (b = b.element || b, a = I.getComputedStyle(b, "").fontSize); a = /px/.test(a)?E(a):/em/.test(a)?12 * parseFloat(a):12; var c = 24 >
        a?a + 4:A(1.2 * a), d = A(.8 * c); return{h:c, b:d, f:a}}, label:function(a, b, c, d, e, f, g, h, k){function l(){var a, b; a = u.element.style; r = (void 0 === ta || void 0 === E || q.styles.textAlign) && u.textStr && u.getBBox(); q.width = (ta || r.width || 0) + 2 * x + C; q.height = (E || r.height || 0) + 2 * x; ja = x + p.fontMetrics(a && a.fontSize, u).b; F && (B || (a = A( - Ga * x), b = h? - ja:0, q.box = B = d?p.symbol(d, a, b, q.width, q.height, R):p.rect(a, b, q.width, q.height, 0, R["stroke-width"]), B.attr("fill", "none").add(q)), B.isImg || B.attr(y({width:A(q.width), height:A(q.height)}, R)),
        R = null)}function m(){var a = q.styles, a = a && a.textAlign, b = C + x * (1 - Ga), c; c = h?0:ja; v(ta) && r && ("center" === a || "right" === a) && (b += {center:.5, right:1}[a] * (ta - r.width)); if (b !== u.x || c !== u.y)u.attr("x", b), c !== w && u.attr("y", c); u.x = b; u.y = c}function n(a, b){B?B.attr(a, b):R[a] = b}var p = this, q = p.g(k), u = p.text("", 0, 0, g).attr({zIndex:1}), B, r, Ga = 0, x = 3, C = 0, ta, E, z, db, G = 0, R = {}, ja, F; q.onAdd = function(){u.add(q); q.attr({text:a || 0 === a?a:"", x:b, y:c}); B && v(e) && q.attr({anchorX:e, anchorY:f})}; q.widthSetter = function(a){ta = a}; q.heightSetter =
        function(a){E = a}; q.paddingSetter = function(a){v(a) && a !== x && (x = a, m())}; q.paddingLeftSetter = function(a){v(a) && a !== C && (C = a, m())}; q.alignSetter = function(a){Ga = {left:0, center:.5, right:1}[a]}; q.textSetter = function(a){a !== w && u.textSetter(a); l(); m()}; q["stroke-widthSetter"] = function(a, b){a && (F = !0); G = a % 2 / 2; n(b, a)}; q.strokeSetter = q.fillSetter = q.rSetter = function(a, b){"fill" === b && a && (F = !0); n(b, a)}; q.anchorXSetter = function(a, b){e = a; n(b, a + G - z)}; q.anchorYSetter = function(a, b){f = a; n(b, a - db)}; q.xSetter = function(a){q.x =
        a; Ga && (a -= Ga * ((ta || r.width) + x)); z = A(a); q.attr("translateX", z)}; q.ySetter = function(a){db = q.y = A(a); q.attr("translateY", db)}; var H = q.css; return y(q, {css:function(a){if (a){var b = {}; a = D(a); t(q.textProps, function(c){a[c] !== w && (b[c] = a[c], delete a[c])}); u.css(b)}return H.call(q, a)}, getBBox:function(){return{width:r.width + 2 * x, height:r.height + 2 * x, x:r.x - x, y:r.y - x}}, shadow:function(a){B && B.shadow(a); return q}, destroy:function(){P(q.element, "mouseenter"); P(q.element, "mouseleave"); u && (u = u.destroy()); B && (B = B.destroy());
        N.prototype.destroy.call(q); q = p = l = m = n = null}})}}; na.prototype = {addLabel:function(){var a = this.axis, b = a.options, c = a.chart, d = a.horiz, e = a.categories, f = a.names, g = this.pos, h = b.labels, k = h.rotation, l = a.tickPositions, d = d && e && !h.step && !h.staggerLines && !h.rotation && c.plotWidth / l.length || !d && (c.margin[3] || .33 * c.chartWidth), m = g === l[0], n = g === l[l.length - 1], p, f = e?r(e[g], f[g], g):g, e = this.label, q = l.info; a.isDatetimeAxis && q && (p = b.dateTimeLabelFormats[q.higherRanks[g] || q.unitName]); this.isFirst = m; this.isLast = n; b = a.labelFormatter.call({axis:a,
        chart:c, isFirst:m, isLast:n, dateTimeLabelFormat:p, value:a.isLog?ea(ga(f)):f}); g = d && {width:x(1, A(d - 2 * (h.padding || 10))) + "px"}; v(e)?e && e.attr({text:b}).css(g):(p = {align:a.labelAlign}, da(k) && (p.rotation = k), d && h.ellipsis && (g.HcHeight = a.len / l.length), this.label = e = v(b) && h.enabled?c.renderer.text(b, 0, 0, h.useHTML).attr(p).css(y(g, h.style)).add(a.labelGroup):null, a.tickBaseline = c.renderer.fontMetrics(h.style.fontSize, e).b, k && 2 === a.side && (a.tickBaseline *= Aa(k * qb))); this.yOffset = e?r(h.y, a.tickBaseline + (2 === a.side?
        8: - (e.getBBox().height / 2))):0}, getLabelSize:function(){var a = this.label, b = this.axis; return a?a.getBBox()[b.horiz?"height":"width"]:0}, getLabelSides:function(){var a = this.label.getBBox(), b = this.axis, c = b.horiz, d = b.options.labels, a = c?a.width:a.height, b = c?d.x - a * {left:0, center:.5, right:1}[b.labelAlign]:0; return[b, c?a + b:a]}, handleOverflow:function(a, b){var c = !0, d = this.axis, e = this.isFirst, f = this.isLast, g = d.horiz?b.x:b.y, h = d.reversed, k = d.tickPositions, l = this.getLabelSides(), m = l[0], l = l[1], n, p, q, u = this.label.line;
        n = u || 0; p = d.labelEdge; q = d.justifyLabels && (e || f); p[n] === w || g + m > p[n]?p[n] = g + l:q || (c = !1); if (q){n = (p = d.justifyToPlot)?d.pos:0; p = p?n + d.len:d.chart.chartWidth; do a += e?1: - 1, q = d.ticks[k[a]]; while (k[a] && (!q || !q.label || q.label.line !== u)); d = q && q.label.xy && q.label.xy.x + q.getLabelSides()[e?0:1]; e && !h || f && h?g + m < n && (g = n - m, q && g + l > d && (c = !1)):g + l > p && (g = p - l, q && g + m < d && (c = !1)); b.x = g}return c}, getPosition:function(a, b, c, d){var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight; return{x:a?e.translate(b + c, null, null,
        d) + e.transB:e.left + e.offset + (e.opposite?(d && f.oldChartWidth || f.chartWidth) - e.right - e.left:0), y:a?g - e.bottom + e.offset - (e.opposite?e.height:0):g - e.translate(b + c, null, null, d) - e.transB}}, getLabelPosition:function(a, b, c, d, e, f, g, h){var k = this.axis, l = k.transA, m = k.reversed, n = k.staggerLines; a = a + e.x - (f && d?f * l * (m? - 1:1):0); b = b + this.yOffset - (f && !d?f * l * (m?1: - 1):0); n && (c.line = g / (h || 1) % n, b += k.labelOffset / n * c.line); return{x:a, y:b}}, getMarkPath:function(a, b, c, d, e, f){return f.crispLine(["M", a, b, "L", a + (e?0: - c), b + (e?
        c:0)], d)}, render:function(a, b, c){var d = this.axis, e = d.options, f = d.chart.renderer, g = d.horiz, h = this.type, k = this.label, l = this.pos, m = e.labels, n = this.gridLine, p = h?h + "Grid":"grid", q = h?h + "Tick":"tick", u = e[p + "LineWidth"], B = e[p + "LineColor"], t = e[p + "LineDashStyle"], v = e[q + "Length"], p = e[q + "Width"] || 0, x = e[q + "Color"], y = e[q + "Position"], q = this.mark, A = m.step, C = !0, E = d.tickmarkOffset, z = this.getPosition(g, l, E, b), D = z.x, z = z.y, R = g && D === d.pos + d.len || !g && z === d.pos? - 1:1; c = r(c, 1); this.isActive = !0; if (u && (l = d.getPlotLinePath(l +
        E, u * R, b, !0), n === w && (n = {stroke:B, "stroke-width":u}, t && (n.dashstyle = t), h || (n.zIndex = 1), b && (n.opacity = 0), this.gridLine = n = u?f.path(l).attr(n).add(d.gridGroup):null), !b && n && l))n[this.isNew?"attr":"animate"]({d:l, opacity:c}); p && v && ("inside" === y && (v = - v), d.opposite && (v = - v), h = this.getMarkPath(D, z, v, p * R, g, f), q?q.animate({d:h, opacity:c}):this.mark = f.path(h).attr({stroke:x, "stroke-width":p, opacity:c}).add(d.axisGroup)); k && !isNaN(D) && (k.xy = z = this.getLabelPosition(D, z, k, g, m, E, a, A), this.isFirst && !this.isLast && !r(e.showFirstLabel,
        1) || this.isLast && !this.isFirst && !r(e.showLastLabel, 1)?C = !1:d.isRadial || m.step || m.rotation || b || 0 === c || (C = this.handleOverflow(a, z)), A && a % A && (C = !1), C && !isNaN(z.y)?(z.opacity = c, k[this.isNew?"attr":"animate"](z), this.isNew = !1):k.attr("y", - 9999))}, destroy:function(){Ka(this, this.axis)}}; za.prototype = {defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L", second:"%H:%M:%S", minute:"%H:%M", hour:"%H:%M", day:"%e. %b", week:"%e. %b", month:"%b '%y", year:"%Y"}, endOnTick:!1, gridLineColor:"#C0C0C0", labels:cb,
        lineColor:"#C0D0E0", lineWidth:1, minPadding:.01, maxPadding:.01, minorGridLineColor:"#E0E0E0", minorGridLineWidth:1, minorTickColor:"#A0A0A0", minorTickLength:2, minorTickPosition:"outside", startOfWeek:1, startOnTick:!1, tickColor:"#C0D0E0", tickLength:10, tickmarkPlacement:"between", tickPixelInterval:100, tickPosition:"outside", tickWidth:1, title:{align:"middle", style:{color:"#707070"}}, type:"linear"}, defaultYAxisOptions:{endOnTick:!0, gridLineWidth:1, tickPixelInterval:72, showLastLabel:!0, labels:{x: - 8, y:3}, lineWidth:0,
        maxPadding:.05, minPadding:.05, startOnTick:!0, tickWidth:0, title:{rotation:270, text:"Values"}, stackLabels:{enabled:!1, formatter:function(){return ha(this.total, - 1)}, style:cb.style}}, defaultLeftAxisOptions:{labels:{x: - 15, y:null}, title:{rotation:270}}, defaultRightAxisOptions:{labels:{x:15, y:null}, title:{rotation:90}}, defaultBottomAxisOptions:{labels:{x:0, y:null}, title:{rotation:0}}, defaultTopAxisOptions:{labels:{x:0, y: - 15}, title:{rotation:0}}, init:function(a, b){var c = b.isX; this.horiz = a.inverted?!c:c;
        this.coll = (this.isXAxis = c)?"xAxis":"yAxis"; this.opposite = b.opposite; this.side = b.side || (this.horiz?this.opposite?0:2:this.opposite?1:3); this.setOptions(b); var d = this.options, e = d.type; this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter; this.userOptions = b; this.minPixelPadding = 0; this.chart = a; this.reversed = d.reversed; this.zoomEnabled = !1 !== d.zoomEnabled; this.categories = d.categories || "category" === e; this.names = []; this.isLog = "logarithmic" === e; this.isDatetimeAxis = "datetime" === e; this.isLinked =
        v(d.linkedTo); this.tickmarkOffset = this.categories && "between" === d.tickmarkPlacement && 1 === r(d.tickInterval, 1)?.5:0; this.ticks = {}; this.labelEdge = []; this.minorTicks = {}; this.plotLinesAndBands = []; this.alternateBands = {}; this.len = 0; this.minRange = this.userMinRange = d.minRange || d.maxZoom; this.range = d.range; this.offset = d.offset || 0; this.stacks = {}; this.oldStacks = {}; this.min = this.max = null; this.crosshair = r(d.crosshair, Z(a.options.tooltip.crosshairs)[c?0:1], !1); var f, d = this.options.events; - 1 === Ta(this, a.axes) && (c &&
        !this.isColorAxis?a.axes.splice(a.xAxis.length, 0, this):a.axes.push(this), a[this.coll].push(this)); this.series = this.series || []; a.inverted && c && this.reversed === w && (this.reversed = !0); this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine; for (f in d)J(this, f, d[f]); this.isLog && (this.val2lin = Ya, this.lin2val = ga)}, setOptions:function(a){this.options = D(this.defaultOptions, this.isXAxis?{}:this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions,
        this.defaultLeftAxisOptions][this.side], D(F[this.coll], a))}, defaultLabelFormatter:function(){var a = this.axis, b = this.value, c = a.categories, d = this.dateTimeLabelFormat, e = F.lang.numericSymbols, f = e && e.length, g, h = a.options.labels.format, a = a.isLog?b:a.tickInterval; if (h)g = xa(h, this); else if (c)g = b; else if (d)g = Ia(d, b); else if (f && 1E3 <= a)for (; f-- && g === w; )c = Math.pow(1E3, f + 1), a >= c && null !== e[f] && (g = ha(b / c, - 1) + e[f]); g === w && (g = 1E4 <= Q(b)?ha(b, 0):ha(b, - 1, w, "")); return g}, getSeriesExtremes:function(){var a = this, b = a.chart;
        a.hasVisibleSeries = !1; a.dataMin = a.dataMax = a.ignoreMinPadding = a.ignoreMaxPadding = null; a.buildStacks && a.buildStacks(); t(a.series, function(c){if (c.visible || !b.options.chart.ignoreHiddenSeries){var d; d = c.options.threshold; var e; a.hasVisibleSeries = !0; a.isLog && 0 >= d && (d = null); a.isXAxis?(d = c.xData, d.length && (a.dataMin = O(r(a.dataMin, d[0]), Ja(d)), a.dataMax = x(r(a.dataMax, d[0]), ya(d)))):(c.getExtremes(), e = c.dataMax, c = c.dataMin, v(c) && v(e) && (a.dataMin = O(r(a.dataMin, c), c), a.dataMax = x(r(a.dataMax, e), e)), v(d) && (a.dataMin >=
        d?(a.dataMin = d, a.ignoreMinPadding = !0):a.dataMax < d && (a.dataMax = d, a.ignoreMaxPadding = !0)))}})}, translate:function(a, b, c, d, e, f){var g = 1, h = 0, k = d?this.oldTransA:this.transA; d = d?this.oldMin:this.min; var l = this.minPixelPadding; e = (this.options.ordinal || this.isLog && e) && this.lin2val; k || (k = this.transA); c && (g *= - 1, h = this.len); this.reversed && (g *= - 1, h -= g * (this.sector || this.len)); b?(a = a * g + h - l, a = a / k + d, e && (a = this.lin2val(a))):(e && (a = this.val2lin(a)), "between" === f && (f = .5), a = g * (a - d) * k + h + g * l + (da(f)?k * f * this.pointRange:
        0)); return a}, toPixels:function(a, b){return this.translate(a, !1, !this.horiz, null, !0) + (b?0:this.pos)}, toValue:function(a, b){return this.translate(a - (b?0:this.pos), !0, !this.horiz, null, !0)}, getPlotLinePath:function(a, b, c, d, e){var f = this.chart, g = this.left, h = this.top, k, l, m = c && f.oldChartHeight || f.chartHeight, n = c && f.oldChartWidth || f.chartWidth, p; k = this.transB; e = r(e, this.translate(a, null, null, c)); a = c = A(e + k); k = l = A(m - e - k); if (isNaN(e))p = !0; else if (this.horiz){if (k = h, l = m - this.bottom, a < g || a > g + this.width)p = !0} else if (a =
        g, c = n - this.right, k < h || k > h + this.height)p = !0; return p && !d?null:f.renderer.crispLine(["M", a, k, "L", c, l], b || 1)}, getLinearTickPositions:function(a, b, c){var d, e = ea(W(b / a) * a), f = ea(qa(c / a) * a), g = []; if (b === c && da(b))return[b]; for (b = e; b <= f; ){g.push(b); b = ea(b + a); if (b === d)break; d = b}return g}, getMinorTickPositions:function(){var a = this.options, b = this.tickPositions, c = this.minorTickInterval, d = [], e; if (this.isLog)for (e = b.length, a = 1; a < e; a++)d = d.concat(this.getLogTickPositions(c, b[a - 1], b[a], !0)); else if (this.isDatetimeAxis &&
        "auto" === a.minorTickInterval)d = d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), this.min, this.max, a.startOfWeek)), d[0] < this.min && d.shift(); else for (b = this.min + (b[0] - this.min) % c; b <= this.max; b += c)d.push(b); return d}, adjustForMinRange:function(){var a = this.options, b = this.min, c = this.max, d, e = this.dataMax - this.dataMin >= this.minRange, f, g, h, k, l; this.isXAxis && this.minRange === w && !this.isLog && (v(a.min) || v(a.max)?this.minRange = null:(t(this.series, function(a){k = a.xData; for (g = l = a.xIncrement?1:k.length -
        1; 0 < g; g--)if (h = k[g] - k[g - 1], f === w || h < f)f = h}), this.minRange = O(5 * f, this.dataMax - this.dataMin))); if (c - b < this.minRange){var m = this.minRange; d = (m - c + b) / 2; d = [b - d, r(a.min, b - d)]; e && (d[2] = this.dataMin); b = ya(d); c = [b + m, r(a.max, b + m)]; e && (c[2] = this.dataMax); c = Ja(c); c - b < m && (d[0] = c - m, d[1] = r(a.min, c - m), b = ya(d))}this.min = b; this.max = c}, setAxisTranslation:function(a){var b = this, c = b.max - b.min, d = b.axisPointRange || 0, e, f = 0, g = 0, h = b.linkedParent, k = !!b.categories, l = b.transA; if (b.isXAxis || k || d)h?(f = h.minPointOffset, g = h.pointRangePadding):
        t(b.series, function(a){var h = k?1:b.isXAxis?a.pointRange:b.axisPointRange || 0, l = a.options.pointPlacement, q = a.closestPointRange; h > c && (h = 0); d = x(d, h); f = x(f, ka(l)?0:h / 2); g = x(g, "on" === l?0:h); !a.noSharedTooltip && v(q) && (e = v(e)?O(e, q):q)}), h = b.ordinalSlope && e?b.ordinalSlope / e:1, b.minPointOffset = f *= h, b.pointRangePadding = g *= h, b.pointRange = O(d, c), b.closestPointRange = e; a && (b.oldTransA = l); b.translationSlope = b.transA = l = b.len / (c + g || 1); b.transB = b.horiz?b.left:b.bottom; b.minPixelPadding = l * f}, setTickPositions:function(a){var b =
        this, c = b.chart, d = b.options, e = d.startOnTick, f = d.endOnTick, g = b.isLog, h = b.isDatetimeAxis, k = b.isXAxis, l = b.isLinked, m = b.options.tickPositioner, n = d.maxPadding, p = d.minPadding, q = d.tickInterval, u = d.minTickInterval, B = d.tickPixelInterval, w, y = b.categories; l?(b.linkedParent = c[b.coll][d.linkedTo], c = b.linkedParent.getExtremes(), b.min = r(c.min, c.dataMin), b.max = r(c.max, c.dataMax), d.type !== b.linkedParent.options.type && X(11, 1)):(b.min = r(b.userMin, d.min, b.dataMin), b.max = r(b.userMax, d.max, b.dataMax)); g && (!a && 0 >= O(b.min,
        r(b.dataMin, b.min)) && X(10, 1), b.min = ea(Ya(b.min)), b.max = ea(Ya(b.max))); b.range && v(b.max) && (b.userMin = b.min = x(b.min, b.max - b.range), b.userMax = b.max, b.range = null); b.beforePadding && b.beforePadding(); b.adjustForMinRange(); !(y || b.axisPointRange || b.usePercentage || l) && v(b.min) && v(b.max) && (c = b.max - b.min) && (v(d.min) || v(b.userMin) || !p || !(0 > b.dataMin) && b.ignoreMinPadding || (b.min -= c * p), v(d.max) || v(b.userMax) || !n || !(0 < b.dataMax) && b.ignoreMaxPadding || (b.max += c * n)); da(d.floor) && (b.min = x(b.min, d.floor)); da(d.ceiling) &&
        (b.max = O(b.max, d.ceiling)); b.min === b.max || void 0 === b.min || void 0 === b.max?b.tickInterval = 1:l && !q && B === b.linkedParent.options.tickPixelInterval?b.tickInterval = b.linkedParent.tickInterval:(b.tickInterval = r(q, y?1:(b.max - b.min) * B / x(b.len, B)), !v(q) && b.len < B && !this.isRadial && !this.isLog && !y && e && f && (w = !0, b.tickInterval /= 4)); k && !a && t(b.series, function(a){a.processData(b.min !== b.oldMin || b.max !== b.oldMax)}); b.setAxisTranslation(!0); b.beforeSetTickPositions && b.beforeSetTickPositions(); b.postProcessTickInterval &&
        (b.tickInterval = b.postProcessTickInterval(b.tickInterval)); b.pointRange && (b.tickInterval = x(b.pointRange, b.tickInterval)); !q && b.tickInterval < u && (b.tickInterval = u); h || g || q || (b.tickInterval = zb(b.tickInterval, null, L.pow(10, W(L.log(b.tickInterval) / L.LN10)), r(d.allowDecimals, !(1 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)))); b.minorTickInterval = "auto" === d.minorTickInterval && b.tickInterval?b.tickInterval / 5:d.minorTickInterval; b.tickPositions = a = d.tickPositions?[].concat(d.tickPositions):m && m.apply(b,
        [b.min, b.max]); a || (!b.ordinalPositions && (b.max - b.min) / b.tickInterval > x(2 * b.len, 200) && X(19, !0), a = h?b.getTimeTicks(b.normalizeTimeTickInterval(b.tickInterval, d.units), b.min, b.max, d.startOfWeek, b.ordinalPositions, b.closestPointRange, !0):g?b.getLogTickPositions(b.tickInterval, b.min, b.max):b.getLinearTickPositions(b.tickInterval, b.min, b.max), w && a.splice(1, a.length - 2), b.tickPositions = a); l || (d = a[0], g = a[a.length - 1], h = b.minPointOffset || 0, e?b.min = d:b.min - h > d && a.shift(), f?b.max = g:b.max + h < g && a.pop(), 0 === a.length &&
        v(d) && a.push((g + d) / 2), 1 === a.length && (e = 1E13 < Q(b.max)?1:.001, b.min -= e, b.max += e))}, setMaxTicks:function(){var a = this.chart, b = a.maxTicks || {}, c = this.tickPositions, d = this._maxTicksKey = [this.coll, this.pos, this.len].join("-"); !this.isLinked && !this.isDatetimeAxis && c && c.length > (b[d] || 0) && !1 !== this.options.alignTicks && (b[d] = c.length); a.maxTicks = b}, adjustTickAmount:function(){var a = this._maxTicksKey, b = this.tickPositions, c = this.chart.maxTicks; if (c && c[a] && !this.isDatetimeAxis && !this.categories && !this.isLinked &&
        !1 !== this.options.alignTicks && this.min !== w){var d = this.tickAmount, e = b.length; this.tickAmount = a = c[a]; if (e < a){for (; b.length < a; )b.push(ea(b[b.length - 1] + this.tickInterval)); this.transA *= (e - 1) / (a - 1); this.max = b[b.length - 1]}v(d) && a !== d && (this.isDirty = !0)}}, setScale:function(){var a = this.stacks, b, c, d, e; this.oldMin = this.min; this.oldMax = this.max; this.oldAxisLength = this.len; this.setAxisSize(); e = this.len !== this.oldAxisLength; t(this.series, function(a){if (a.isDirtyData || a.isDirty || a.xAxis.isDirty)d = !0}); if (e ||
        d || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax){if (!this.isXAxis)for (b in a)for (c in a[b])a[b][c].total = null, a[b][c].cum = 0; this.forceRedraw = !1; this.getSeriesExtremes(); this.setTickPositions(); this.oldUserMin = this.userMin; this.oldUserMax = this.userMax; this.isDirty || (this.isDirty = e || this.min !== this.oldMin || this.max !== this.oldMax)} else if (!this.isXAxis)for (b in this.oldStacks && (a = this.stacks = this.oldStacks), a)for (c in a[b])a[b][c].cum = a[b][c].total;
        this.setMaxTicks()}, setExtremes:function(a, b, c, d, e){var f = this, g = f.chart; c = r(c, !0); e = y(e, {min:a, max:b}); z(f, "setExtremes", e, function(){f.userMin = a; f.userMax = b; f.eventArgs = e; f.isDirtyExtremes = !0; c && g.redraw(d)})}, zoom:function(a, b){var c = this.dataMin, d = this.dataMax, e = this.options; this.allowZoomOutside || (v(c) && a <= O(c, r(e.min, c)) && (a = w), v(d) && b >= x(d, r(e.max, d)) && (b = w)); this.displayBtn = a !== w || b !== w; this.setExtremes(a, b, !1, w, {trigger:"zoom"}); return!0}, setAxisSize:function(){var a = this.chart, b = this.options,
        c = b.offsetLeft || 0, d = this.horiz, e = r(b.width, a.plotWidth - c + (b.offsetRight || 0)), f = r(b.height, a.plotHeight), g = r(b.top, a.plotTop), b = r(b.left, a.plotLeft + c), c = /%$/; c.test(f) && (f = parseInt(f, 10) / 100 * a.plotHeight); c.test(g) && (g = parseInt(g, 10) / 100 * a.plotHeight + a.plotTop); this.left = b; this.top = g; this.width = e; this.height = f; this.bottom = a.chartHeight - f - g; this.right = a.chartWidth - e - b; this.len = x(d?e:f, 0); this.pos = d?b:g}, getExtremes:function(){var a = this.isLog; return{min:a?ea(ga(this.min)):this.min, max:a?ea(ga(this.max)):
        this.max, dataMin:this.dataMin, dataMax:this.dataMax, userMin:this.userMin, userMax:this.userMax}}, getThreshold:function(a){var b = this.isLog, c = b?ga(this.min):this.min, b = b?ga(this.max):this.max; c > a || null === a?a = c:b < a && (a = b); return this.translate(a, 0, 1, 0, 1)}, autoLabelAlign:function(a){a = (r(a, 0) - 90 * this.side + 720) % 360; return 15 < a && 165 > a?"right":195 < a && 345 > a?"left":"center"}, getOffset:function(){var a = this, b = a.chart, c = b.renderer, d = a.options, e = a.tickPositions, f = a.ticks, g = a.horiz, h = a.side, k = b.inverted?[1, 0, 3,
2][h]:h, l, m, n = 0, p, q = 0, u = d.title, B = d.labels, U = 0, y = b.axisOffset, b = b.clipOffset, A = [ - 1, 1, 1, - 1][h], z, C = 1, E = r(B.maxStaggerLines, 5), D, G, F, R, ja; a.hasData = l = a.hasVisibleSeries || v(a.min) && v(a.max) && !!e; a.showAxis = m = l || r(d.showEmpty, !0); a.staggerLines = a.horiz && B.staggerLines; a.axisGroup || (a.gridGroup = c.g("grid").attr({zIndex:d.gridZIndex || 1}).add(), a.axisGroup = c.g("axis").attr({zIndex:d.zIndex || 2}).add(), a.labelGroup = c.g("axis-labels").attr({zIndex:B.zIndex || 7}).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add());
        if (l || a.isLinked){a.labelAlign = r(B.align || a.autoLabelAlign(B.rotation)); t(e, function(b){f[b]?f[b].addLabel():f[b] = new na(a, b)}); if (a.horiz && !a.staggerLines && E && !B.rotation){for (l = a.reversed?[].concat(e).reverse():e; C < E; ){D = []; G = !1; for (z = 0; z < l.length; z++)F = l[z], R = (R = f[F].label && f[F].label.getBBox())?R.width:0, ja = z % C, R && (F = a.translate(F), D[ja] !== w && F < D[ja] && (G = !0), D[ja] = F + R); if (G)C++; else break}1 < C && (a.staggerLines = C)}t(e, function(b){if (0 === h || 2 === h || {1:"left", 3:"right"}[h] === a.labelAlign)U = x(f[b].getLabelSize(),
        U)}); a.staggerLines && (U *= a.staggerLines, a.labelOffset = U)} else for (z in f)f[z].destroy(), delete f[z]; u && u.text && !1 !== u.enabled && (a.axisTitle || (a.axisTitle = c.text(u.text, 0, 0, u.useHTML).attr({zIndex:7, rotation:u.rotation || 0, align:u.textAlign || {low:"left", middle:"center", high:"right"}[u.align]}).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(u.style).add(a.axisGroup), a.axisTitle.isNew = !0), m && (n = a.axisTitle.getBBox()[g?"height":"width"], p = u.offset, q = v(p)?0:r(u.margin, g?5:10)), a.axisTitle[m?
        "show":"hide"]()); a.offset = A * r(d.offset, y[h]); c = 2 === h?a.tickBaseline:0; g = U + q + (U && A * (g?r(B.y, a.tickBaseline + 8):B.x) - c); a.axisTitleMargin = r(p, g); y[h] = x(y[h], a.axisTitleMargin + n + A * a.offset, g); b[k] = x(b[k], 2 * W(d.lineWidth / 2))}, getLinePath:function(a){var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c?this.width:0) + d, d = b.chartHeight - this.bottom - (c?this.height:0) + d; c && (a *= - 1); return b.renderer.crispLine(["M", e?this.left:f, e?d:this.top, "L", e?b.chartWidth - this.right:f, e?d:b.chartHeight -
        this.bottom], a)}, getTitlePosition:function(){var a = this.horiz, b = this.left, c = this.top, d = this.len, e = this.options.title, f = a?b:c, g = this.opposite, h = this.offset, k = E(e.style.fontSize || 12), d = {low:f + (a?0:d), middle:f + d / 2, high:f + (a?d:0)}[e.align], b = (a?c + this.height:b) + (a?1: - 1) * (g? - 1:1) * this.axisTitleMargin + (2 === this.side?k:0); return{x:a?d:b + (g?this.width:0) + h + (e.x || 0), y:a?b - (g?this.height:0) + h:d + (e.y || 0)}}, render:function(){var a = this, b = a.horiz, c = a.reversed, d = a.chart, e = d.renderer, f = a.options, g = a.isLog, h = a.isLinked,
        k = a.tickPositions, l, m = a.axisTitle, n = a.ticks, p = a.minorTicks, q = a.alternateBands, u = f.stackLabels, r = f.alternateGridColor, x = a.tickmarkOffset, y = f.lineWidth, z = d.hasRendered && v(a.oldMin) && !isNaN(a.oldMin), C = a.hasData, A = a.showAxis, D, E = f.labels.overflow, F = a.justifyLabels = b && !1 !== E, G; a.labelEdge.length = 0; a.justifyToPlot = "justify" === E; t([n, p, q], function(a){for (var b in a)a[b].isActive = !1}); if (C || h)a.minorTickInterval && !a.categories && t(a.getMinorTickPositions(), function(b){p[b] || (p[b] = new na(a, b, "minor")); z &&
        p[b].isNew && p[b].render(null, !0); p[b].render(null, !1, 1)}), k.length && (l = k.slice(), (b && c || !b && !c) && l.reverse(), F && (l = l.slice(1).concat([l[0]])), t(l, function(b, c){F && (c = c === l.length - 1?0:c + 1); if (!h || b >= a.min && b <= a.max)n[b] || (n[b] = new na(a, b)), z && n[b].isNew && n[b].render(c, !0, .1), n[b].render(c)}), x && 0 === a.min && (n[ - 1] || (n[ - 1] = new na(a, - 1, null, !0)), n[ - 1].render( - 1))), r && t(k, function(b, c){0 === c % 2 && b < a.max && (q[b] || (q[b] = new M.PlotLineOrBand(a)), D = b + x, G = k[c + 1] !== w?k[c + 1] + x:a.max, q[b].options = {from:g?ga(D):D,
        to:g?ga(G):G, color:r}, q[b].render(), q[b].isActive = !0)}), a._addedPlotLB || (t((f.plotLines || []).concat(f.plotBands || []), function(b){a.addPlotBandOrLine(b)}), a._addedPlotLB = !0); t([n, p, q], function(a){var b, c, e = [], f = ba?ba.duration || 500:0, g = function(){for (c = e.length; c--; )a[e[c]] && !a[e[c]].isActive && (a[e[c]].destroy(), delete a[e[c]])}; for (b in a)a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, e.push(b)); a !== q && d.hasRendered && f?f && setTimeout(g, f):g()}); y && (b = a.getLinePath(y), a.axisLine?a.axisLine.animate({d:b}):
        a.axisLine = e.path(b).attr({stroke:f.lineColor, "stroke-width":y, zIndex:7}).add(a.axisGroup), a.axisLine[A?"show":"hide"]()); m && A && (m[m.isNew?"attr":"animate"](a.getTitlePosition()), m.isNew = !1); u && u.enabled && a.renderStackTotals(); a.isDirty = !1}, redraw:function(){this.render(); t(this.plotLinesAndBands, function(a){a.render()}); t(this.series, function(a){a.isDirty = !0})}, destroy:function(a){var b = this, c = b.stacks, d, e = b.plotLinesAndBands; a || P(b); for (d in c)Ka(c[d]), c[d] = null; t([b.ticks, b.minorTicks, b.alternateBands],
        function(a){Ka(a)}); for (a = e.length; a--; )e[a].destroy(); t("stackTotalGroup axisLine axisTitle axisGroup cross gridGroup labelGroup".split(" "), function(a){b[a] && (b[a] = b[a].destroy())}); this.cross && this.cross.destroy()}, drawCrosshair:function(a, b){if (this.crosshair)if (!1 === (v(b) || !r(this.crosshair.snap, !0)))this.hideCrosshair(); else{var c, d = this.crosshair, e = d.animation; r(d.snap, !0)?v(b) && (c = this.chart.inverted != this.horiz?b.plotX:this.len - b.plotY):c = this.horiz?a.chartX - this.pos:this.len - a.chartY + this.pos;
        c = this.isRadial?this.getPlotLinePath(this.isXAxis?b.x:r(b.stackY, b.y)):this.getPlotLinePath(null, null, null, null, c); if (null === c)this.hideCrosshair(); else if (this.cross)this.cross.attr({visibility:"visible"})[e?"animate":"attr"]({d:c}, e); else e = {"stroke-width":d.width || 1, stroke:d.color || "#C0C0C0", zIndex:d.zIndex || 2}, d.dashStyle && (e.dashstyle = d.dashStyle), this.cross = this.chart.renderer.path(c).attr(e).add()}}, hideCrosshair:function(){this.cross && this.cross.hide()}}; y(za.prototype, void 0); var wb = M.Tooltip =
        function(){this.init.apply(this, arguments)}; wb.prototype = {init:function(a, b){var c = b.borderWidth, d = b.style, e = E(d.padding); this.chart = a; this.options = b; this.crosshairs = []; this.now = {x:0, y:0}; this.isHidden = !0; this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({padding:e, fill:b.backgroundColor, "stroke-width":c, r:b.borderRadius, zIndex:8}).css(d).css({padding:0}).add().attr({y: - 9999}); aa || this.label.shadow(b.shadow); this.shared = b.shared}, destroy:function(){this.label &&
        (this.label = this.label.destroy()); clearTimeout(this.hideTimer); clearTimeout(this.tooltipTimeout)}, move:function(a, b, c, d){var e = this, f = e.now, g = !1 !== e.options.animation && !e.isHidden && (1 < Q(a - f.x) || 1 < Q(b - f.y)), h = e.followPointer || 1 < e.len; y(f, {x:g?(2 * f.x + a) / 3:a, y:g?(f.y + b) / 2:b, anchorX:h?w:g?(2 * f.anchorX + c) / 3:c, anchorY:h?w:g?(f.anchorY + d) / 2:d}); e.label.attr(f); g && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function(){e && e.move(a, b, c, d)}, 32))}, hide:function(a){var b = this, c; clearTimeout(this.hideTimer);
        this.isHidden || (c = this.chart.hoverPoints, this.hideTimer = setTimeout(function(){b.label.fadeOut(); b.isHidden = !0}, r(a, this.options.hideDelay, 500)), c && t(c, function(a){a.setState()}), this.chart.hoverPoints = null)}, getAnchor:function(a, b){var c, d = this.chart, e = d.inverted, f = d.plotTop, g = 0, h = 0, k; a = Z(a); c = a[0].tooltipPos; this.followPointer && b && (b.chartX === w && (b = d.pointer.normalize(b)), c = [b.chartX - d.plotLeft, b.chartY - f]); c || (t(a, function(a){k = a.series.yAxis; g += a.plotX; h += (a.plotLow?(a.plotLow + a.plotHigh) / 2:a.plotY) +
        (!e && k?k.top - f:0)}), g /= a.length, h /= a.length, c = [e?d.plotWidth - h:g, this.shared && !e && 1 < a.length && b?b.chartY - f:e?d.plotHeight - g:h]); return Ea(c, A)}, getPosition:function(a, b, c){var d = this.chart, e = this.distance, f = {}, g, h = ["y", d.chartHeight, b, c.plotY + d.plotTop], k = ["x", d.chartWidth, a, c.plotX + d.plotLeft], l = c.ttBelow || d.inverted && !c.negative || !d.inverted && c.negative, m = function(a, b, c, d){var g = c < d - e; b = d + e + c < b; c = d - e - c; d += e; if (l && b)f[a] = d; else if (!l && g)f[a] = c; else if (g)f[a] = c; else if (b)f[a] = d; else return!1}, n = function(a,
        b, c, d){if (d < e || d > b - e)return!1; f[a] = d < c / 2?1:d > b - c / 2?b - c - 2:d - c / 2}, p = function(a){var b = h; h = k; k = b; g = a}, q = function(){!1 !== m.apply(0, h)?!1 !== n.apply(0, k) || g || (p(!0), q()):g?f.x = f.y = 0:(p(!0), q())}; (d.inverted || 1 < this.len) && p(); q(); return f}, defaultFormatter:function(a){var b = this.points || Z(this), c = b[0].series, d; d = [a.tooltipHeaderFormatter(b[0])]; t(b, function(a){c = a.series; d.push(c.tooltipFormatter && c.tooltipFormatter(a) || a.point.tooltipFormatter(c.tooltipOptions.pointFormat))}); d.push(a.options.footerFormat ||
        ""); return d.join("")}, refresh:function(a, b){var c = this.chart, d = this.label, e = this.options, f, g, h = {}, k, l = []; k = e.formatter || this.defaultFormatter; var h = c.hoverPoints, m, n = this.shared; clearTimeout(this.hideTimer); this.followPointer = Z(a)[0].series.tooltipOptions.followPointer; g = this.getAnchor(a, b); f = g[0]; g = g[1]; !n || a.series && a.series.noSharedTooltip?h = a.getLabelConfig():(c.hoverPoints = a, h && t(h, function(a){a.setState()}), t(a, function(a){a.setState("hover"); l.push(a.getLabelConfig())}), h = {x:a[0].category,
        y:a[0].y}, h.points = l, this.len = l.length, a = a[0]); k = k.call(h, this); h = a.series; this.distance = r(h.tooltipOptions.distance, 16); !1 === k?this.hide():(this.isHidden && (Ua(d), d.attr("opacity", 1).show()), d.attr({text:k}), m = e.borderColor || a.color || h.color || "#606060", d.attr({stroke:m}), this.updatePosition({plotX:f, plotY:g, negative:a.negative, ttBelow:a.ttBelow}), this.isHidden = !1); z(c, "tooltipRefresh", {text:k, x:f + c.plotLeft, y:g + c.plotTop, borderColor:m})}, updatePosition:function(a){var b = this.chart, c = this.label, c =
        (this.options.positioner || this.getPosition).call(this, c.width, c.height, a); this.move(A(c.x), A(c.y), a.plotX + b.plotLeft, a.plotY + b.plotTop)}, tooltipHeaderFormatter:function(a){var b = a.series, c = b.tooltipOptions, d = c.dateTimeLabelFormats, e = c.xDateFormat, f = b.xAxis, g = f && "datetime" === f.options.type && da(a.key), c = c.headerFormat, f = f && f.closestPointRange, h; if (g && !e){if (f)for (h in ra){if (ra[h] >= f || ra[h] <= ra.day && 0 < a.key % ra[h]){e = d[h]; break}} else e = d.day; e = e || d.year}g && e && (c = c.replace("{point.key}", "{point.key:" +
        e + "}")); return xa(c, {point:a, series:b})}}; var ua; Ba = C.documentElement.ontouchstart !== w; var eb = M.Pointer = function(a, b){this.init(a, b)}; eb.prototype = {init:function(a, b){var c = b.chart, d = c.events, e = aa?"":c.zoomType, c = a.inverted, f; this.options = b; this.chart = a; this.zoomX = f = /x/.test(e); this.zoomY = e = /y/.test(e); this.zoomHor = f && !c || e && c; this.zoomVert = e && !c || f && c; this.hasZoom = f || e; this.runChartClick = d && !!d.click; this.pinchDown = []; this.lastValidTouch = {}; M.Tooltip && b.tooltip.enabled && (a.tooltip = new wb(a, b.tooltip),
        this.followTouchMove = b.tooltip.followTouchMove); this.setDOMEvents()}, normalize:function(a, b){var c, d; a = a || window.event; a = Fb(a); a.target || (a.target = a.srcElement); d = a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:a; b || (this.chartPosition = b = Eb(this.chart.container)); d.pageX === w?(c = x(a.x, a.clientX - b.left), d = a.y):(c = d.pageX - b.left, d = d.pageY - b.top); return y(a, {chartX:A(c), chartY:A(d)})}, getCoordinates:function(a){var b = {xAxis:[], yAxis:[]}; t(this.chart.axes, function(c){b[c.isXAxis?"xAxis":
        "yAxis"].push({axis:c, value:c.toValue(a[c.horiz?"chartX":"chartY"])})}); return b}, getIndex:function(a){var b = this.chart; return b.inverted?b.plotHeight + b.plotTop - a.chartY:a.chartX - b.plotLeft}, runPointActions:function(a){var b = this.chart, c = b.series, d = b.tooltip, e, f, g = b.hoverPoint, h = b.hoverSeries, k, l, m = b.chartWidth, n = this.getIndex(a); if (d && this.options.tooltip.shared && (!h || !h.noSharedTooltip)){f = []; k = c.length; for (l = 0; l < k; l++)c[l].visible && !1 !== c[l].options.enableMouseTracking && !c[l].noSharedTooltip &&
        !0 !== c[l].singularTooltips && c[l].tooltipPoints.length && (e = c[l].tooltipPoints[n]) && e.series && (e._dist = Q(n - e.clientX), m = O(m, e._dist), f.push(e)); for (k = f.length; k--; )f[k]._dist > m && f.splice(k, 1); f.length && f[0].clientX !== this.hoverX && (d.refresh(f, a), this.hoverX = f[0].clientX)}c = h && h.tooltipOptions.followPointer; if (h && h.tracker && !c){if ((e = h.tooltipPoints[n]) && e !== g)e.onMouseOver(a)} else d && c && !d.isHidden && (h = d.getAnchor([{}], a), d.updatePosition({plotX:h[0], plotY:h[1]})); d && !this._onDocumentMouseMove && (this._onDocumentMouseMove =
        function(a){if (T[ua])T[ua].pointer.onDocumentMouseMove(a)}, J(C, "mousemove", this._onDocumentMouseMove)); t(b.axes, function(b){b.drawCrosshair(a, r(e, g))})}, reset:function(a, b){var c = this.chart, d = c.hoverSeries, e = c.hoverPoint, f = c.tooltip, g = f && f.shared?c.hoverPoints:e; (a = a && f && g) && Z(g)[0].plotX === w && (a = !1); if (a)f.refresh(g), e && e.setState(e.state, !0); else{if (e)e.onMouseOut(); if (d)d.onMouseOut(); f && f.hide(b); this._onDocumentMouseMove && (P(C, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove =
        null); t(c.axes, function(a){a.hideCrosshair()}); this.hoverX = null}}, scaleGroups:function(a, b){var c = this.chart, d; t(c.series, function(e){d = a || e.getPlotBox(); e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b?c.clipRect:null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d))}); c.clipRect.attr(b || c.clipBox)}, dragStart:function(a){var b = this.chart; b.mouseIsDown = a.type; b.cancelClick = !1; b.mouseDownX = this.mouseDownX = a.chartX; b.mouseDownY = this.mouseDownY =
        a.chartY}, drag:function(a){var b = this.chart, c = b.options.chart, d = a.chartX, e = a.chartY, f = this.zoomHor, g = this.zoomVert, h = b.plotLeft, k = b.plotTop, l = b.plotWidth, m = b.plotHeight, n, p = this.mouseDownX, q = this.mouseDownY, u = c.panKey && a[c.panKey + "Key"]; d < h?d = h:d > h + l && (d = h + l); e < k?e = k:e > k + m && (e = k + m); this.hasDragged = Math.sqrt(Math.pow(p - d, 2) + Math.pow(q - e, 2)); 10 < this.hasDragged && (n = b.isInsidePlot(p - h, q - k), b.hasCartesianSeries && (this.zoomX || this.zoomY) && n && !u && !this.selectionMarker && (this.selectionMarker = b.renderer.rect(h,
        k, f?1:l, g?1:m, 0).attr({fill:c.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex:7}).add()), this.selectionMarker && f && (d -= p, this.selectionMarker.attr({width:Q(d), x:(0 < d?0:d) + p})), this.selectionMarker && g && (d = e - q, this.selectionMarker.attr({height:Q(d), y:(0 < d?0:d) + q})), n && !this.selectionMarker && c.panning && b.pan(a, c.panning))}, drop:function(a){var b = this.chart, c = this.hasPinched; if (this.selectionMarker){var d = {xAxis:[], yAxis:[], originalEvent:a.originalEvent || a}, e = this.selectionMarker, f = e.attr?e.attr("x"):
        e.x, g = e.attr?e.attr("y"):e.y, h = e.attr?e.attr("width"):e.width, k = e.attr?e.attr("height"):e.height, l; if (this.hasDragged || c)t(b.axes, function(b){if (b.zoomEnabled){var c = b.horiz, e = "touchend" === a.type?b.minPixelPadding:0, q = b.toValue((c?f:g) + e), c = b.toValue((c?f + h:g + k) - e); isNaN(q) || isNaN(c) || (d[b.coll].push({axis:b, min:O(q, c), max:x(q, c)}), l = !0)}}), l && z(b, "selection", d, function(a){b.zoom(y(a, c?{animation:!1}:null))}); this.selectionMarker = this.selectionMarker.destroy(); c && this.scaleGroups()}b && (S(b.container,
        {cursor:b._cursor}), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])}, onContainerMouseDown:function(a){a = this.normalize(a); a.preventDefault && a.preventDefault(); this.dragStart(a)}, onDocumentMouseUp:function(a){T[ua] && T[ua].pointer.drop(a)}, onDocumentMouseMove:function(a){var b = this.chart, c = this.chartPosition, d = b.hoverSeries; a = this.normalize(a, c); c && d && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) &&
        this.reset()}, onContainerMouseLeave:function(){var a = T[ua]; a && (a.pointer.reset(), a.pointer.chartPosition = null)}, onContainerMouseMove:function(a){var b = this.chart; ua = b.index; a = this.normalize(a); a.returnValue = !1; "mousedown" === b.mouseIsDown && this.drag(a); !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a)}, inClass:function(a, b){for (var c; a; ){if (c = G(a, "class")){if ( - 1 !== c.indexOf(b))return!0; if ( - 1 !== c.indexOf("highcharts-container"))return!1}a =
        a.parentNode}}, onTrackerMouseOut:function(a){var b = this.chart.hoverSeries, c = (a = a.relatedTarget || a.toElement) && a.point && a.point.series; if (b && !b.options.stickyTracking && !this.inClass(a, "highcharts-tooltip") && c !== b)b.onMouseOut()}, onContainerClick:function(a){var b = this.chart, c = b.hoverPoint, d = b.plotLeft, e = b.plotTop; a = this.normalize(a); a.cancelBubble = !0; b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker")?(z(c.series, "click", y(a, {point:c})), b.hoverPoint && c.firePointEvent("click", a)):(y(a, this.getCoordinates(a)),
        b.isInsidePlot(a.chartX - d, a.chartY - e) && z(b, "click", a)))}, setDOMEvents:function(){var a = this, b = a.chart.container; b.onmousedown = function(b){a.onContainerMouseDown(b)}; b.onmousemove = function(b){a.onContainerMouseMove(b)}; b.onclick = function(b){a.onContainerClick(b)}; J(b, "mouseleave", a.onContainerMouseLeave); 1 === Da && J(C, "mouseup", a.onDocumentMouseUp); Ba && (b.ontouchstart = function(b){a.onContainerTouchStart(b)}, b.ontouchmove = function(b){a.onContainerTouchMove(b)}, 1 === Da && J(C, "touchend", a.onDocumentTouchEnd))},
        destroy:function(){var a; P(this.chart.container, "mouseleave", this.onContainerMouseLeave); Da || (P(C, "mouseup", this.onDocumentMouseUp), P(C, "touchend", this.onDocumentTouchEnd)); clearInterval(this.tooltipTimeout); for (a in this)this[a] = null}}; var Va = M.Legend = function(a, b){this.init(a, b)}; Va.prototype = {init:function(a, b){var c = this, d = b.itemStyle, e = r(b.padding, 8), f = b.itemMarginTop || 0; this.options = b; b.enabled && (c.itemStyle = d, c.itemHiddenStyle = D(d, b.itemHiddenStyle), c.itemMarginTop = f, c.padding = e, c.initialItemX =
        e, c.initialItemY = e - 5, c.maxItemWidth = 0, c.chart = a, c.itemHeight = 0, c.lastLineHeight = 0, c.symbolWidth = r(b.symbolWidth, 16), c.pages = [], c.render(), J(c.chart, "endResize", function(){c.positionCheckboxes()}))}, colorizeItem:function(a, b){var c = this.options, d = a.legendItem, e = a.legendLine, f = a.legendSymbol, g = this.itemHiddenStyle.color, c = b?c.itemStyle.color:g, h = b?a.legendColor || a.color || "#CCC":g, g = a.options && a.options.marker, k = {fill:h}, l; d && d.css({fill:c, color:c}); e && e.attr({stroke:h}); if (f){if (g && f.isMarker)for (l in k.stroke =
        h, g = a.convertAttribs(g), g)d = g[l], d !== w && (k[l] = d); f.attr(k)}}, positionItem:function(a){var b = this.options, c = b.symbolPadding, b = !b.rtl, d = a._legendItemPos, e = d[0], d = d[1], f = a.checkbox; a.legendGroup && a.legendGroup.translate(b?e:this.legendWidth - e - 2 * c - 4, d); f && (f.x = e, f.y = d)}, destroyItem:function(a){var b = a.checkbox; t(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b){a[b] && (a[b] = a[b].destroy())}); b && La(a.checkbox)}, destroy:function(){var a = this.group, b = this.box; b && (this.box = b.destroy());
        a && (this.group = a.destroy())}, positionCheckboxes:function(a){var b = this.group.alignAttr, c, d = this.clipHeight || this.legendHeight; b && (c = b.translateY, t(this.allItems, function(e){var f = e.checkbox, g; f && (g = c + f.y + (a || 0) + 3, S(f, {left:b.translateX + e.checkboxOffset + f.x - 20 + "px", top:g + "px", display:g > c - 6 && g < c + d - 6?"":"none"}))}))}, renderTitle:function(){var a = this.padding, b = this.options.title, c = 0; b.text && (this.title || (this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({zIndex:1}).css(b.style).add(this.group)),
        a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({translateY:c})); this.titleHeight = c}, renderItem:function(a){var b = this.chart, c = b.renderer, d = this.options, e = "horizontal" === d.layout, f = this.symbolWidth, g = d.symbolPadding, h = this.itemStyle, k = this.itemHiddenStyle, l = this.padding, m = e?r(d.itemDistance, 20):0, n = !d.rtl, p = d.width, q = d.itemMarginBottom || 0, u = this.itemMarginTop, B = this.initialItemX, t = a.legendItem, v = a.series && a.series.drawLegendSymbol?a.series:a, w = v.options, w = this.createCheckboxForItem &&
        w && w.showCheckbox, y = d.useHTML; t || (a.legendGroup = c.g("legend-item").attr({zIndex:1}).add(this.scrollGroup), a.legendItem = t = c.text(d.labelFormat?xa(d.labelFormat, a):d.labelFormatter.call(a), n?f + g: - g, this.baseline || 0, y).css(D(a.visible?h:k)).attr({align:n?"left":"right", zIndex:2}).add(a.legendGroup), this.baseline || (this.baseline = c.fontMetrics(h.fontSize, t).f + 3 + u, t.attr("y", this.baseline)), v.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, t, y, h, k), this.colorizeItem(a, a.visible), w && this.createCheckboxForItem(a));
        c = t.getBBox(); f = a.checkboxOffset = d.itemWidth || a.legendItemWidth || f + g + c.width + m + (w?20:0); this.itemHeight = g = A(a.legendItemHeight || c.height); e && this.itemX - B + f > (p || b.chartWidth - 2 * l - B - d.x) && (this.itemX = B, this.itemY += u + this.lastLineHeight + q, this.lastLineHeight = 0); this.maxItemWidth = x(this.maxItemWidth, f); this.lastItemY = u + this.itemY + q; this.lastLineHeight = x(g, this.lastLineHeight); a._legendItemPos = [this.itemX, this.itemY]; e?this.itemX += f:(this.itemY += u + g + q, this.lastLineHeight = g); this.offsetWidth = p || x((e?this.itemX -
        B - m:f) + l, this.offsetWidth)}, getAllItems:function(){var a = []; t(this.chart.series, function(b){var c = b.options; r(c.showInLegend, v(c.linkedTo)?!1:w, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType?b.data:b)))}); return a}, render:function(){var a = this, b = a.chart, c = b.renderer, d = a.group, e, f, g, h, k = a.box, l = a.options, m = a.padding, n = l.borderWidth, p = l.backgroundColor; a.itemX = a.initialItemX; a.itemY = a.initialItemY; a.offsetWidth = 0; a.lastItemY = 0; d || (a.group = d = c.g("legend").attr({zIndex:7}).add(), a.contentGroup =
        c.g().attr({zIndex:1}).add(d), a.scrollGroup = c.g().add(a.contentGroup)); a.renderTitle(); e = a.getAllItems(); $a(e, function(a, b){return(a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)}); l.reversed && e.reverse(); a.allItems = e; a.display = f = !!e.length; t(e, function(b){a.renderItem(b)}); g = l.width || a.offsetWidth; h = a.lastItemY + a.lastLineHeight + a.titleHeight; h = a.handleOverflow(h); if (n || p)g += m, h += m, k?0 < g && 0 < h && (k[k.isNew?"attr":"animate"](k.crisp({width:g, height:h})), k.isNew = !1):(a.box =
        k = c.rect(0, 0, g, h, l.borderRadius, n || 0).attr({stroke:l.borderColor, "stroke-width":n || 0, fill:p || "none"}).add(d).shadow(l.shadow), k.isNew = !0), k[f?"show":"hide"](); a.legendWidth = g; a.legendHeight = h; t(e, function(b){a.positionItem(b)}); f && d.align(y({width:g, height:h}, l), !0, "spacingBox"); b.isResizing || this.positionCheckboxes()}, handleOverflow:function(a){var b = this, c = this.chart, d = c.renderer, e = this.options, f = e.y, f = c.spacingBox.height + ("top" === e.verticalAlign? - f:f) - this.padding, g = e.maxHeight, h, k = this.clipRect,
        l = e.navigation, m = r(l.animation, !0), n = l.arrowSize || 12, p = this.nav, q = this.pages, u, B = this.allItems; "horizontal" === e.layout && (f /= 2); g && (f = O(f, g)); q.length = 0; a > f && !e.useHTML?(this.clipHeight = h = x(f - 20 - this.titleHeight - this.padding, 0), this.currentPage = r(this.currentPage, 1), this.fullHeight = a, t(B, function(a, b){var c = a._legendItemPos[1], d = A(a.legendItem.getBBox().height), e = q.length; if (!e || c - q[e - 1] > h && (u || c) !== q[e - 1])q.push(u || c), e++; b === B.length - 1 && c + d - q[e - 1] > h && q.push(c); c !== u && (u = c)}), k || (k = b.clipRect = d.clipRect(0,
        this.padding, 9999, 0), b.contentGroup.clip(k)), k.attr({height:h}), p || (this.nav = p = d.g().attr({zIndex:1}).add(this.group), this.up = d.symbol("triangle", 0, 0, n, n).on("click", function(){b.scroll( - 1, m)}).add(p), this.pager = d.text("", 15, 10).css(l.style).add(p), this.down = d.symbol("triangle-down", 0, 0, n, n).on("click", function(){b.scroll(1, m)}).add(p)), b.scroll(0), a = f):p && (k.attr({height:c.chartHeight}), p.hide(), this.scrollGroup.attr({translateY:1}), this.clipHeight = 0); return a}, scroll:function(a, b){var c = this.pages,
        d = c.length, e = this.currentPage + a, f = this.clipHeight, g = this.options.navigation, h = g.activeColor, g = g.inactiveColor, k = this.pager, l = this.padding; e > d && (e = d); 0 < e && (b !== w && (ba = r(b, this.chart.animation)), this.nav.attr({translateX:l, translateY:f + this.padding + 7 + this.titleHeight, visibility:"visible"}), this.up.attr({fill:1 === e?g:h}).css({cursor:1 === e?"default":"pointer"}), k.attr({text:e + "/" + d}), this.down.attr({x:18 + this.pager.getBBox().width, fill:e === d?g:h}).css({cursor:e === d?"default":"pointer"}), c = - c[e - 1] + this.initialItemY,
        this.scrollGroup.animate({translateY:c}), this.currentPage = e, this.positionCheckboxes(c))}}; var xb = M.LegendSymbolMixin = {drawRectangle:function(a, b){var c = a.options.symbolHeight || 12; b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 5 - c / 2, a.symbolWidth, c, a.options.symbolRadius || 0).attr({zIndex:3}).add(b.legendGroup)}, drawLineMarker:function(a){var b = this.options, c = b.marker, d; d = a.symbolWidth; var e = this.chart.renderer, f = this.legendGroup; a = a.baseline - A(.3 * e.fontMetrics(a.options.itemStyle.fontSize, this.legendItem).b);
        var g; b.lineWidth && (g = {"stroke-width":b.lineWidth}, b.dashStyle && (g.dashstyle = b.dashStyle), this.legendLine = e.path(["M", 0, a, "L", d, a]).attr(g).add(f)); c && !1 !== c.enabled && (b = c.radius, this.legendSymbol = d = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b).add(f), d.isMarker = !0)}}; (/Trident\/7\.0/.test(ia) || Qa) && H(Va.prototype, "positionItem", function(a, b){var c = this, d = function(){b._legendItemPos && a.call(c, b)}; d(); setTimeout(d)}); Oa.prototype = {init:function(a, b){var c, d = a.series; a.series = null; c = D(F, a); c.series = a.series =
        d; this.userOptions = a; d = c.chart; this.margin = this.splashArray("margin", d); this.spacing = this.splashArray("spacing", d); var e = d.events; this.bounds = {h:{}, v:{}}; this.callback = b; this.isResizing = 0; this.options = c; this.axes = []; this.series = []; this.hasCartesianSeries = d.showAxes; var f = this, g; f.index = T.length; T.push(f); Da++; !1 !== d.reflow && J(f, "load", function(){f.initReflow()}); if (e)for (g in e)J(f, g, e[g]); f.xAxis = []; f.yAxis = []; f.animation = aa?!1:r(d.animation, !0); f.pointCount = f.colorCounter = f.symbolCounter = 0; f.firstRender()},
        initSeries:function(a){var b = this.options.chart; (b = K[a.type || b.type || b.defaultSeriesType]) || X(17, !0); b = new b; b.init(this, a); return b}, isInsidePlot:function(a, b, c){var d = c?b:a; a = c?a:b; return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight}, adjustTickAmounts:function(){!1 !== this.options.chart.alignTicks && t(this.axes, function(a){a.adjustTickAmount()}); this.maxTicks = null}, redraw:function(a){var b = this.axes, c = this.series, d = this.pointer, e = this.legend, f = this.isDirtyLegend, g, h, k = this.hasCartesianSeries,
        l = this.isDirtyBox, m = c.length, n = m, p = this.renderer, q = p.isHidden(), u = []; ba = r(a, this.animation); q && this.cloneRenderTo(); for (this.layOutTitles(); n--; )if (a = c[n], a.options.stacking && (g = !0, a.isDirty)){h = !0; break}if (h)for (n = m; n--; )a = c[n], a.options.stacking && (a.isDirty = !0); t(c, function(a){a.isDirty && "point" === a.options.legendType && (f = !0)}); f && e.options.enabled && (e.render(), this.isDirtyLegend = !1); g && this.getStacks(); k && (this.isResizing || (this.maxTicks = null, t(b, function(a){a.setScale()})), this.adjustTickAmounts());
        this.getMargins(); k && (t(b, function(a){a.isDirty && (l = !0)}), t(b, function(a){a.isDirtyExtremes && (a.isDirtyExtremes = !1, u.push(function(){z(a, "afterSetExtremes", y(a.eventArgs, a.getExtremes())); delete a.eventArgs})); (l || g) && a.redraw()})); l && this.drawChartBox(); t(c, function(a){a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw()}); d && d.reset(!0); p.draw(); z(this, "redraw"); q && this.cloneRenderTo(!0); t(u, function(a){a.call()})}, get:function(a){var b = this.axes, c = this.series, d, e; for (d = 0; d < b.length; d++)if (b[d].options.id ===
        a)return b[d]; for (d = 0; d < c.length; d++)if (c[d].options.id === a)return c[d]; for (d = 0; d < c.length; d++)for (e = c[d].points || [], b = 0; b < e.length; b++)if (e[b].id === a)return e[b]; return null}, getAxes:function(){var a = this, b = this.options, c = b.xAxis = Z(b.xAxis || {}), b = b.yAxis = Z(b.yAxis || {}); t(c, function(a, b){a.index = b; a.isX = !0}); t(b, function(a, b){a.index = b}); c = c.concat(b); t(c, function(b){new za(a, b)}); a.adjustTickAmounts()}, getSelectedPoints:function(){var a = []; t(this.series, function(b){a = a.concat(tb(b.points || [], function(a){return a.selected}))});
        return a}, getSelectedSeries:function(){return tb(this.series, function(a){return a.selected})}, getStacks:function(){var a = this; t(a.yAxis, function(a){a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks)}); t(a.series, function(b){!b.options.stacking || !0 !== b.visible && !1 !== a.options.chart.ignoreHiddenSeries || (b.stackKey = b.type + r(b.options.stack, ""))})}, setTitle:function(a, b, c){var d = this, e = d.options, f; f = e.title = D(e.title, a); e = e.subtitle = D(e.subtitle, b); t([["title", a, f], ["subtitle", b, e]], function(a){var b =
        a[0], c = d[b], e = a[1]; a = a[2]; c && e && (d[b] = c = c.destroy()); a && a.text && !c && (d[b] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({align:a.align, "class":"highcharts-" + b, zIndex:a.zIndex || 4}).css(a.style).add())}); d.layOutTitles(c)}, layOutTitles:function(a){var b = 0, c = this.title, d = this.subtitle, e = this.options, f = e.title, e = e.subtitle, g = this.renderer, h = this.spacingBox.width - 44; c && (c.css({width:(f.width || h) + "px"}).align(y({y:g.fontMetrics(f.style.fontSize, c).b - 3}, f), !1, "spacingBox"), f.floating || f.verticalAlign || (b = c.getBBox().height));
        d && (d.css({width:(e.width || h) + "px"}).align(y({y:b + (f.margin - 13) + g.fontMetrics(f.style.fontSize, d).b}, e), !1, "spacingBox"), e.floating || e.verticalAlign || (b = qa(b + d.getBBox().height))); c = this.titleOffset !== b; this.titleOffset = b; !this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && r(a, !0) && this.isDirtyBox && this.redraw())}, getChartSize:function(){var a = this.options.chart, b = a.width, a = a.height, c = this.renderToClone || this.renderTo; v(b) || (this.containerWidth = Sa(c, "width")); v(a) || (this.containerHeight = Sa(c,
        "height")); this.chartWidth = x(0, b || this.containerWidth || 600); this.chartHeight = x(0, r(a, 19 < this.containerHeight?this.containerHeight:400))}, cloneRenderTo:function(a){var b = this.renderToClone, c = this.container; a?b && (this.renderTo.appendChild(c), La(b), delete this.renderToClone):(c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), S(b, {position:"absolute", top:"-9999px", display:"block"}), b.style.setProperty && b.style.setProperty("display", "block", "important"),
        C.body.appendChild(b), c && b.appendChild(c))}, getContainer:function(){var a, b = this.options.chart, c, d, e; this.renderTo = a = b.renderTo; e = "highcharts-" + ab++; ka(a) && (this.renderTo = a = C.getElementById(a)); a || X(13, !0); c = E(G(a, "data-highcharts-chart")); !isNaN(c) && T[c] && T[c].hasRendered && T[c].destroy(); G(a, "data-highcharts-chart", this.index); a.innerHTML = ""; b.skipClone || a.offsetWidth || this.cloneRenderTo(); this.getChartSize(); c = this.chartWidth; d = this.chartHeight; this.container = a = pa("div", {className:"highcharts-container" +
        (b.className?" " + b.className:""), id:e}, y({position:"relative", overflow:"hidden", width:c + "px", height:d + "px", textAlign:"left", lineHeight:"normal", zIndex:0, "-webkit-tap-highlight-color":"rgba(0,0,0,0)"}, b.style), this.renderToClone || a); this._cursor = a.style.cursor; this.renderer = b.forExport?new Fa(a, c, d, b.style, !0):new Fa(a, c, d, b.style); aa && this.renderer.create(this, a, c, d)}, getMargins:function(){var a = this.spacing, b, c = this.legend, d = this.margin, e = this.options.legend, f = r(e.margin, 20), g = e.x, h = e.y, k = e.align,
        l = e.verticalAlign, m = this.titleOffset; this.resetMargins(); b = this.axisOffset; m && !v(d[0]) && (this.plotTop = x(this.plotTop, m + this.options.title.margin + a[0])); c.display && !e.floating && ("right" === k?v(d[1]) || (this.marginRight = x(this.marginRight, c.legendWidth - g + f + a[1])):"left" === k?v(d[3]) || (this.plotLeft = x(this.plotLeft, c.legendWidth + g + f + a[3])):"top" === l?v(d[0]) || (this.plotTop = x(this.plotTop, c.legendHeight + h + f + a[0])):"bottom" !== l || v(d[2]) || (this.marginBottom = x(this.marginBottom, c.legendHeight - h + f + a[2]))); this.extraBottomMargin &&
        (this.marginBottom += this.extraBottomMargin); this.extraTopMargin && (this.plotTop += this.extraTopMargin); this.hasCartesianSeries && t(this.axes, function(a){a.getOffset()}); v(d[3]) || (this.plotLeft += b[3]); v(d[0]) || (this.plotTop += b[0]); v(d[2]) || (this.marginBottom += b[2]); v(d[1]) || (this.marginRight += b[1]); this.setChartSize()}, reflow:function(a){var b = this, c = b.options.chart, d = b.renderTo, e = c.width || Sa(d, "width"), f = c.height || Sa(d, "height"), c = a?a.target:I, d = function(){b.container && (b.setSize(e, f, !1), b.hasUserSize =
        null)}; if (!b.hasUserSize && e && f && (c === I || c === C)){if (e !== b.containerWidth || f !== b.containerHeight)clearTimeout(b.reflowTimeout), a?b.reflowTimeout = setTimeout(d, 100):d(); b.containerWidth = e; b.containerHeight = f}}, initReflow:function(){var a = this, b = function(b){a.reflow(b)}; J(I, "resize", b); J(a, "destroy", function(){P(I, "resize", b)})}, setSize:function(a, b, c){var d = this, e, f, g; d.isResizing += 1; g = function(){d && z(d, "endResize", null, function(){--d.isResizing})}; ba = r(c, d.animation); d.oldChartHeight = d.chartHeight; d.oldChartWidth =
        d.chartWidth; v(a) && (d.chartWidth = e = x(0, A(a)), d.hasUserSize = !!e); v(b) && (d.chartHeight = f = x(0, A(b))); (ba?ub:S)(d.container, {width:e + "px", height:f + "px"}, ba); d.setChartSize(!0); d.renderer.setSize(e, f, c); d.maxTicks = null; t(d.axes, function(a){a.isDirty = !0; a.setScale()}); t(d.series, function(a){a.isDirty = !0}); d.isDirtyLegend = !0; d.isDirtyBox = !0; d.layOutTitles(); d.getMargins(); d.redraw(c); d.oldChartHeight = null; z(d, "resize"); !1 === ba?g():setTimeout(g, ba && ba.duration || 500)}, setChartSize:function(a){var b = this.inverted,
        c = this.renderer, d = this.chartWidth, e = this.chartHeight, f = this.options.chart, g = this.spacing, h = this.clipOffset, k, l, m, n; this.plotLeft = k = A(this.plotLeft); this.plotTop = l = A(this.plotTop); this.plotWidth = m = x(0, A(d - k - this.marginRight)); this.plotHeight = n = x(0, A(e - l - this.marginBottom)); this.plotSizeX = b?n:m; this.plotSizeY = b?m:n; this.plotBorderWidth = f.plotBorderWidth || 0; this.spacingBox = c.spacingBox = {x:g[3], y:g[0], width:d - g[3] - g[1], height:e - g[0] - g[2]}; this.plotBox = c.plotBox = {x:k, y:l, width:m, height:n}; d = 2 * W(this.plotBorderWidth /
        2); b = qa(x(d, h[3]) / 2); c = qa(x(d, h[0]) / 2); this.clipBox = {x:b, y:c, width:W(this.plotSizeX - x(d, h[1]) / 2 - b), height:x(0, W(this.plotSizeY - x(d, h[2]) / 2 - c))}; a || t(this.axes, function(a){a.setAxisSize(); a.setAxisTranslation()})}, resetMargins:function(){var a = this.spacing, b = this.margin; this.plotTop = r(b[0], a[0]); this.marginRight = r(b[1], a[1]); this.marginBottom = r(b[2], a[2]); this.plotLeft = r(b[3], a[3]); this.axisOffset = [0, 0, 0, 0]; this.clipOffset = [0, 0, 0, 0]}, drawChartBox:function(){var a = this.options.chart, b = this.renderer,
        c = this.chartWidth, d = this.chartHeight, e = this.chartBackground, f = this.plotBackground, g = this.plotBorder, h = this.plotBGImage, k = a.borderWidth || 0, l = a.backgroundColor, m = a.plotBackgroundColor, n = a.plotBackgroundImage, p = a.plotBorderWidth || 0, q, r = this.plotLeft, t = this.plotTop, v = this.plotWidth, w = this.plotHeight, x = this.plotBox, y = this.clipRect, z = this.clipBox; q = k + (a.shadow?8:0); if (k || l)e?e.animate(e.crisp({width:c - q, height:d - q})):(e = {fill:l || "none"}, k && (e.stroke = a.borderColor, e["stroke-width"] = k), this.chartBackground =
        b.rect(q / 2, q / 2, c - q, d - q, a.borderRadius, k).attr(e).addClass("highcharts-background").add().shadow(a.shadow)); m && (f?f.animate(x):this.plotBackground = b.rect(r, t, v, w, 0).attr({fill:m}).add().shadow(a.plotShadow)); n && (h?h.animate(x):this.plotBGImage = b.image(n, r, t, v, w).add()); y?y.animate({width:z.width, height:z.height}):this.clipRect = b.clipRect(z); p && (g?g.animate(g.crisp({x:r, y:t, width:v, height:w, strokeWidth: - p})):this.plotBorder = b.rect(r, t, v, w, 0, - p).attr({stroke:a.plotBorderColor, "stroke-width":p, fill:"none",
        zIndex:1}).add()); this.isDirtyBox = !1}, propFromSeries:function(){var a = this, b = a.options.chart, c, d = a.options.series, e, f; t(["inverted", "angular", "polar"], function(g){c = K[b.type || b.defaultSeriesType]; f = a[g] || b[g] || c && c.prototype[g]; for (e = d && d.length; !f && e--; )(c = K[d[e].type]) && c.prototype[g] && (f = !0); a[g] = f})}, linkSeries:function(){var a = this, b = a.series; t(b, function(a){a.linkedSeries.length = 0}); t(b, function(b){var d = b.options.linkedTo; ka(d) && (d = ":previous" === d?a.series[b.index - 1]:a.get(d)) && (d.linkedSeries.push(b),
        b.linkedParent = d)})}, renderSeries:function(){t(this.series, function(a){a.translate(); a.setTooltipPoints && a.setTooltipPoints(); a.render()})}, renderLabels:function(){var a = this, b = a.options.labels; b.items && t(b.items, function(c){var d = y(b.style, c.style), e = E(d.left) + a.plotLeft, f = E(d.top) + a.plotTop + 12; delete d.left; delete d.top; a.renderer.text(c.html, e, f).attr({zIndex:2}).css(d).add()})}, render:function(){var a = this.axes, b = this.renderer, c = this.options; this.setTitle(); this.legend = new Va(this, c.legend); this.getStacks();
        t(a, function(a){a.setScale()}); this.getMargins(); this.maxTicks = null; t(a, function(a){a.setTickPositions(!0); a.setMaxTicks()}); this.adjustTickAmounts(); this.getMargins(); this.drawChartBox(); this.hasCartesianSeries && t(a, function(a){a.render()}); this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({zIndex:3}).add()); this.renderSeries(); this.renderLabels(); this.showCredits(c.credits); this.hasRendered = !0}, showCredits:function(a){a.enabled && !this.credits && (this.credits = this.renderer.text(a.text,
        0, 0).on("click", function(){a.href && (location.href = a.href)}).attr({align:a.position.align, zIndex:8}).css(a.style).add().align(a.position))}, destroy:function(){var a = this, b = a.axes, c = a.series, d = a.container, e, f = d && d.parentNode; z(a, "destroy"); T[a.index] = w; Da--; a.renderTo.removeAttribute("data-highcharts-chart"); P(a); for (e = b.length; e--; )b[e] = b[e].destroy(); for (e = c.length; e--; )c[e] = c[e].destroy(); t("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer scroller rangeSelector legend resetZoomButton tooltip renderer".split(" "),
        function(b){var c = a[b]; c && c.destroy && (a[b] = c.destroy())}); d && (d.innerHTML = "", P(d), f && La(d)); for (e in a)delete a[e]}, isReadyToRender:function(){var a = this; return!V && I == I.top && "complete" !== C.readyState || aa && !I.canvg?(aa?CanVGController.push(function(){a.firstRender()}, a.options.global.canvasToolsURL):C.attachEvent("onreadystatechange", function(){C.detachEvent("onreadystatechange", a.firstRender); "complete" === C.readyState && a.firstRender()}), !1):!0}, firstRender:function(){var a = this, b = a.options, c = a.callback;
        a.isReadyToRender() && (a.getContainer(), z(a, "init"), a.resetMargins(), a.setChartSize(), a.propFromSeries(), a.getAxes(), t(b.series || [], function(b){a.initSeries(b)}), a.linkSeries(), z(a, "beforeRender"), M.Pointer && (a.pointer = new eb(a, b)), a.render(), a.renderer.draw(), c && c.apply(a, [a]), t(a.callbacks, function(b){b.apply(a, [a])}), a.cloneRenderTo(!0), z(a, "load"))}, splashArray:function(a, b){var c = b[a], c = ca(c)?c:[c, c, c, c]; return[r(b[a + "Top"], c[0]), r(b[a + "Right"], c[1]), r(b[a + "Bottom"], c[2]), r(b[a + "Left"], c[3])]}};
        Oa.prototype.callbacks = []; var Kb = M.CenteredSeriesMixin = {getCenter:function(){var a = this.options, b = this.chart, c = 2 * (a.slicedOffset || 0), d, e = b.plotWidth - 2 * c, f = b.plotHeight - 2 * c, b = a.center, a = [r(b[0], "50%"), r(b[1], "50%"), a.size || "100%", a.innerSize || 0], g = O(e, f), h; return Ea(a, function(a, b){h = /%$/.test(a); d = 2 > b || 2 === b && h; return(h?[e, f, g, g][b] * E(a) / 100:a) + (d?c:0)})}}, Ha = function(){}; Ha.prototype = {init:function(a, b, c){this.series = a; this.applyOptions(b, c); this.pointAttr = {}; a.options.colorByPoint && (b = a.options.colors ||
        a.chart.options.colors, this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length && (a.colorCounter = 0)); a.chart.pointCount++; return this}, applyOptions:function(a, b){var c = this.series, d = c.options.pointValKey || c.pointValKey; a = Ha.prototype.optionsToObject.call(this, a); y(this, a); this.options = this.options?y(this.options, a):a; d && (this.y = this[d]); this.x === w && c && (this.x = b === w?c.autoIncrement():b); return this}, optionsToObject:function(a){var b = {}, c = this.series, d = c.pointArrayMap || ["y"], e = d.length,
        f = 0, g = 0; if ("number" === typeof a || null === a)b[d[0]] = a; else if (va(a))for (a.length > e && (c = typeof a[0], "string" === c?b.name = a[0]:"number" === c && (b.x = a[0]), f++); g < e; )b[d[g++]] = a[f++]; else"object" === typeof a && (b = a, a.dataLabels && (c._hasPointLabels = !0), a.marker && (c._hasPointMarkers = !0)); return b}, destroy:function(){var a = this.series.chart, b = a.hoverPoints, c; a.pointCount--; b && (this.setState(), wa(b, this), b.length || (a.hoverPoints = null)); if (this === a.hoverPoint)this.onMouseOut(); if (this.graphic || this.dataLabel)P(this),
        this.destroyElements(); this.legendItem && a.legend.destroyItem(this); for (c in this)this[c] = null}, destroyElements:function(){for (var a = "graphic dataLabel dataLabelUpper group connector shadowGroup".split(" "), b, c = 6; c--; )b = a[c], this[b] && (this[b] = this[b].destroy())}, getLabelConfig:function(){return{x:this.category, y:this.y, key:this.name || this.category, series:this.series, point:this, percentage:this.percentage, total:this.total || this.stackTotal}}, tooltipFormatter:function(a){var b = this.series, c = b.tooltipOptions,
        d = r(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || ""; t(b.pointArrayMap || ["y"], function(b){b = "{point." + b; if (e || f)a = a.replace(b + "}", e + b + "}" + f); a = a.replace(b + "}", b + ":,." + d + "f}")}); return xa(a, {point:this, series:this.series})}, firePointEvent:function(a, b, c){var d = this, e = this.series.options; (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(); "click" === a && e.allowPointSelect && (c = function(a){d.select(null, a.ctrlKey || a.metaKey || a.shiftKey)}); z(this, a, b, c)}};
        var fa = function(){}; fa.prototype = {isCartesian:!0, type:"line", pointClass:Ha, sorted:!0, requireSorting:!0, pointAttrToOptions:{stroke:"lineColor", "stroke-width":"lineWidth", fill:"fillColor", r:"radius"}, axisTypes:["xAxis", "yAxis"], colorCounter:0, parallelArrays:["x", "y"], init:function(a, b){var c = this, d, e, f = a.series, g = function(a, b){return r(a.options.index, a._i) - r(b.options.index, b._i)}; c.chart = a; c.options = b = c.setOptions(b); c.linkedSeries = []; c.bindAxes(); y(c, {name:b.name, state:"", pointAttr:{}, visible:!1 !==
        b.visible, selected:!0 === b.selected}); aa && (b.animation = !1); e = b.events; for (d in e)J(c, d, e[d]); if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect)a.runTrackerClick = !0; c.getColor(); c.getSymbol(); t(c.parallelArrays, function(a){c[a + "Data"] = []}); c.setData(b.data, !1); c.isCartesian && (a.hasCartesianSeries = !0); f.push(c); c._i = f.length - 1; $a(f, g); this.yAxis && $a(this.yAxis.series, g); t(f, function(a, b){a.index = b; a.name = a.name || "Series " + (b + 1)})}, bindAxes:function(){var a = this, b = a.options,
        c = a.chart, d; t(a.axisTypes || [], function(e){t(c[e], function(c){d = c.options; if (b[e] === d.index || b[e] !== w && b[e] === d.id || b[e] === w && 0 === d.index)c.series.push(a), a[e] = c, c.isDirty = !0}); a[e] || a.optionalAxis === e || X(18, !0)})}, updateParallelArrays:function(a, b){var c = a.series, d = arguments; t(c.parallelArrays, "number" === typeof b?function(d){var f = "y" === d && c.toYData?c.toYData(a):a[d]; c[d + "Data"][b] = f}:function(a){Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2))})}, autoIncrement:function(){var a =
        this.options, b = this.xIncrement, b = r(b, a.pointStart, 0); this.pointInterval = r(this.pointInterval, a.pointInterval, 1); this.xIncrement = b + this.pointInterval; return b}, getSegments:function(){var a = - 1, b = [], c, d = this.points, e = d.length; if (e)if (this.options.connectNulls){for (c = e; c--; )null === d[c].y && d.splice(c, 1); d.length && (b = [d])} else t(d, function(c, g){null === c.y?(g > a + 1 && b.push(d.slice(a + 1, g)), a = g):g === e - 1 && b.push(d.slice(a + 1, g + 1))}); this.segments = b}, setOptions:function(a){var b = this.chart, c = b.options.plotOptions,
        b = b.userOptions || {}, d = b.plotOptions || {}, e = c[this.type]; this.userOptions = a; c = D(e, c.series, a); this.tooltipOptions = D(F.tooltip, F.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip); null === e.marker && delete c.marker; return c}, getCyclic:function(a, b, c){var d = this.userOptions, e = "_" + a + "Index", f = a + "Counter"; b || (v(d[e])?b = d[e]:(d[e] = b = this.chart[f] % c.length, this.chart[f] += 1), b = c[b]); this[a] = b}, getColor:function(){this.options.colorByPoint || this.getCyclic("color",
        this.options.color || sa[this.type].color, this.chart.options.colors)}, getSymbol:function(){var a = this.options.marker; this.getCyclic("symbol", a.symbol, this.chart.options.symbols); /^url/.test(this.symbol) && (a.radius = 0)}, drawLegendSymbol:xb.drawLineMarker, setData:function(a, b, c, d){var e = this, f = e.points, g = f && f.length || 0, h, k = e.options, l = e.chart, m = null, n = e.xAxis, p = n && !!n.categories, q = e.tooltipPoints, u = k.turboThreshold, B = this.xData, v = this.yData, x = (h = e.pointArrayMap) && h.length; a = a || []; h = a.length; b = r(b, !0);
        if (!1 === d || !h || g !== h || e.cropped || e.hasGroupedData){e.xIncrement = null; e.pointRange = p?1:k.pointRange; e.colorCounter = 0; t(this.parallelArrays, function(a){e[a + "Data"].length = 0}); if (u && h > u){for (c = 0; null === m && c < h; )m = a[c], c++; if (da(m)){p = r(k.pointStart, 0); k = r(k.pointInterval, 1); for (c = 0; c < h; c++)B[c] = p, v[c] = a[c], p += k; e.xIncrement = p} else if (va(m))if (x)for (c = 0; c < h; c++)k = a[c], B[c] = k[0], v[c] = k.slice(1, x + 1); else for (c = 0; c < h; c++)k = a[c], B[c] = k[0], v[c] = k[1]; else X(12)} else for (c = 0; c < h; c++)a[c] !== w && (k = {series:e}, e.pointClass.prototype.applyOptions.apply(k,
        [a[c]]), e.updateParallelArrays(k, c), p && k.name && (n.names[k.x] = k.name)); ka(v[0]) && X(14, !0); e.data = []; e.options.data = a; for (c = g; c--; )f[c] && f[c].destroy && f[c].destroy(); q && (q.length = 0); n && (n.minRange = n.userMinRange); e.isDirty = e.isDirtyData = l.isDirtyBox = !0; c = !1} else t(a, function(a, b){f[b].update(a, !1, null, !1)}); b && l.redraw(c)}, processData:function(a){var b = this.xData, c = this.yData, d = b.length, e; e = 0; var f, g, h = this.xAxis, k, l = this.options; k = l.cropThreshold; var m = 0, n = this.isCartesian, p, q; if (n && !this.isDirty &&
        !h.isDirty && !this.yAxis.isDirty && !a)return!1; h && (p = h.getExtremes(), q = p.min, p = p.max); if (n && this.sorted && (!k || d > k || this.forceCrop))if (b[d - 1] < q || b[0] > p)b = [], c = []; else if (b[0] < q || b[d - 1] > p)e = this.cropData(this.xData, this.yData, q, p), b = e.xData, c = e.yData, e = e.start, f = !0, m = b.length; for (k = b.length - 1; 0 <= k; k--)d = b[k] - b[k - 1], !f && b[k] > q && b[k] < p && m++, 0 < d && (g === w || d < g)?g = d:0 > d && this.requireSorting && X(15); this.cropped = f; this.cropStart = e; this.processedXData = b; this.processedYData = c; this.activePointCount = m; null === l.pointRange &&
        (this.pointRange = g || 1); this.closestPointRange = g}, cropData:function(a, b, c, d){var e = a.length, f = 0, g = e, h = r(this.cropShoulder, 1), k; for (k = 0; k < e; k++)if (a[k] >= c){f = x(0, k - h); break}for (; k < e; k++)if (a[k] > d){g = k + h; break}return{xData:a.slice(f, g), yData:b.slice(f, g), start:f, end:g}}, generatePoints:function(){var a = this.options.data, b = this.data, c, d = this.processedXData, e = this.processedYData, f = this.pointClass, g = d.length, h = this.cropStart || 0, k, l = this.hasGroupedData, m, n = [], p; b || l || (b = [], b.length = a.length, b = this.data = b);
        for (p = 0; p < g; p++)k = h + p, l?n[p] = (new f).init(this, [d[p]].concat(Z(e[p]))):(b[k]?m = b[k]:a[k] !== w && (b[k] = m = (new f).init(this, a[k], d[p])), n[p] = m), n[p].index = k; if (b && (g !== (c = b.length) || l))for (p = 0; p < c; p++)p !== h || l || (p += g), b[p] && (b[p].destroyElements(), b[p].plotX = w); this.data = b; this.points = n}, getExtremes:function(a){var b = this.yAxis, c = this.processedXData, d, e = [], f = 0; d = this.xAxis.getExtremes(); var g = d.min, h = d.max, k, l, m, n; a = a || this.stackedYData || this.processedYData; d = a.length; for (n = 0; n < d; n++)if (l = c[n], m = a[n],
        k = null !== m && m !== w && (!b.isLog || m.length || 0 < m), l = this.getExtremesFromAll || this.cropped || (c[n + 1] || l) >= g && (c[n - 1] || l) <= h, k && l)if (k = m.length)for (; k--; )null !== m[k] && (e[f++] = m[k]); else e[f++] = m; this.dataMin = r(void 0, Ja(e)); this.dataMax = r(void 0, ya(e))}, translate:function(){this.processedXData || this.processData(); this.generatePoints(); for (var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.yAxis, f = this.points, g = f.length, h = !!this.modifyValue, k = a.pointPlacement, l = "between" === k || da(k), m = a.threshold,
        a = 0; a < g; a++){var n = f[a], p = n.x, q = n.y, u = n.low, t = b && e.stacks[(this.negStacks && q < m?"-":"") + this.stackKey]; e.isLog && 0 >= q && (n.y = q = null, X(10)); n.plotX = c.translate(p, 0, 0, 0, 1, k, "flags" === this.type); b && this.visible && t && t[p] && (t = t[p], q = t.points[this.index + "," + a], u = q[0], q = q[1], 0 === u && (u = r(m, e.min)), e.isLog && 0 >= u && (u = null), n.total = n.stackTotal = t.total, n.percentage = t.total && n.y / t.total * 100, n.stackY = q, t.setOffset(this.pointXOffset || 0, this.barW || 0)); n.yBottom = v(u)?e.translate(u, 0, 1, 0, 1):null; h && (q = this.modifyValue(q,
        n)); n.plotY = "number" === typeof q && Infinity !== q?e.translate(q, 0, 1, 0, 1):w; n.clientX = l?c.translate(p, 0, 0, 0, 1):n.plotX; n.negative = n.y < (m || 0); n.category = d && d[n.x] !== w?d[n.x]:n.x}this.getSegments()}, animate:function(a){var b = this.chart, c = b.renderer, d; d = this.options.animation; var e = this.clipBox || b.clipBox, f = b.inverted, g; d && !ca(d) && (d = sa[this.type].animation); g = ["_sharedClip", d.duration, d.easing, e.height].join(); a?(a = b[g], d = b[g + "m"], a || (b[g] = a = c.clipRect(y(e, {width:0})), b[g + "m"] = d = c.clipRect( - 99, f? - b.plotLeft:
        - b.plotTop, 99, f?b.chartWidth:b.chartHeight)), this.group.clip(a), this.markerGroup.clip(d), this.sharedClipKey = g):((a = b[g]) && a.animate({width:b.plotSizeX}, d), b[g + "m"] && b[g + "m"].animate({width:b.plotSizeX + 99}, d), this.animate = null)}, afterAnimate:function(){var a = this.chart, b = this.sharedClipKey, c = this.group, d = this.clipBox; c && !1 !== this.options.clip && (b && d || c.clip(d?a.renderer.clipRect(d):a.clipRect), this.markerGroup.clip()); z(this, "afterAnimate"); setTimeout(function(){b && a[b] && (d || (a[b] = a[b].destroy()),
        a[b + "m"] && (a[b + "m"] = a[b + "m"].destroy()))}, 100)}, drawPoints:function(){var a, b = this.points, c = this.chart, d, e, f, g, h, k, l, m, n = this.options.marker, p = this.pointAttr[""], q, t, v, x = this.markerGroup, z = r(n.enabled, !this.requireSorting || this.activePointCount < .5 * this.xAxis.len / n.radius); if (!1 !== n.enabled || this._hasPointMarkers)for (f = b.length; f--; )g = b[f], d = W(g.plotX), e = g.plotY, m = g.graphic, q = g.marker || {}, t = !!g.marker, a = z && q.enabled === w || q.enabled, v = c.isInsidePlot(A(d), e, c.inverted), a && e !== w && !isNaN(e) && null !== g.y?
        (a = g.pointAttr[g.selected?"select":""] || p, h = a.r, k = r(q.symbol, this.symbol), l = 0 === k.indexOf("url"), m?m[v?"show":"hide"](!0).animate(y({x:d - h, y:e - h}, m.symbolName?{width:2 * h, height:2 * h}:{})):v && (0 < h || l) && (g.graphic = c.renderer.symbol(k, d - h, e - h, 2 * h, 2 * h, t?q:n).attr(a).add(x))):m && (g.graphic = m.destroy())}, convertAttribs:function(a, b, c, d){var e = this.pointAttrToOptions, f, g, h = {}; a = a || {}; b = b || {}; c = c || {}; d = d || {}; for (f in e)g = e[f], h[f] = r(a[g], b[f], c[f], d[f]); return h}, getAttribs:function(){var a = this, b = a.options,
        c = sa[a.type].marker?b.marker:b, d = c.states, e = d.hover, f, g = a.color; f = {stroke:g, fill:g}; var h = a.points || [], k, l = [], m, n = a.pointAttrToOptions; m = a.hasPointSpecificOptions; var p = b.negativeColor, q = c.lineColor, r = c.fillColor; k = b.turboThreshold; var w; b.marker?(e.radius = e.radius || c.radius + e.radiusPlus, e.lineWidth = e.lineWidth || c.lineWidth + e.lineWidthPlus):e.color = e.color || oa(e.color || g).brighten(e.brightness).get(); l[""] = a.convertAttribs(c, f); t(["hover", "select"], function(b){l[b] = a.convertAttribs(d[b], l[""])});
        a.pointAttr = l; g = h.length; if (!k || g < k || m)for (; g--; ){k = h[g]; (c = k.options && k.options.marker || k.options) && !1 === c.enabled && (c.radius = 0); k.negative && p && (k.color = k.fillColor = p); m = b.colorByPoint || k.color; if (k.options)for (w in n)v(c[n[w]]) && (m = !0); m?(c = c || {}, m = [], d = c.states || {}, f = d.hover = d.hover || {}, b.marker || (f.color = f.color || !k.options.color && e.color || oa(k.color).brighten(f.brightness || e.brightness).get()), f = {color:k.color}, r || (f.fillColor = k.color), q || (f.lineColor = k.color), m[""] = a.convertAttribs(y(f, c), l[""]),
        m.hover = a.convertAttribs(d.hover, l.hover, m[""]), m.select = a.convertAttribs(d.select, l.select, m[""])):m = l; k.pointAttr = m}}, destroy:function(){var a = this, b = a.chart, c = /AppleWebKit\/533/.test(ia), d, e, f = a.data || [], g, h, k; z(a, "destroy"); P(a); t(a.axisTypes || [], function(b){if (k = a[b])wa(k.series, a), k.isDirty = k.forceRedraw = !0}); a.legendItem && a.chart.legend.destroyItem(a); for (e = f.length; e--; )(g = f[e]) && g.destroy && g.destroy(); a.points = null; clearTimeout(a.animationTimeout); t("area graph dataLabelsGroup group markerGroup tracker graphNeg areaNeg posClip negClip".split(" "),
        function(b){a[b] && (d = c && "group" === b?"hide":"destroy", a[b][d]())}); b.hoverSeries === a && (b.hoverSeries = null); wa(b.series, a); for (h in a)delete a[h]}, getSegmentPath:function(a){var b = this, c = [], d = b.options.step; t(a, function(e, f){var g = e.plotX, h = e.plotY, k; b.getPointSpline?c.push.apply(c, b.getPointSpline(a, e, f)):(c.push(f?"L":"M"), d && f && (k = a[f - 1], "right" === d?c.push(k.plotX, h):"center" === d?c.push((k.plotX + g) / 2, k.plotY, (k.plotX + g) / 2, h):c.push(g, k.plotY)), c.push(e.plotX, e.plotY))}); return c}, getGraphPath:function(){var a =
        this, b = [], c, d = []; t(a.segments, function(e){c = a.getSegmentPath(e); 1 < e.length?b = b.concat(c):d.push(e[0])}); a.singlePoints = d; return a.graphPath = b}, drawGraph:function(){var a = this, b = this.options, c = [["graph", b.lineColor || this.color]], d = b.lineWidth, e = b.dashStyle, f = "square" !== b.linecap, g = this.getGraphPath(), h = b.negativeColor; h && c.push(["graphNeg", h]); t(c, function(c, h){var m = c[0], n = a[m]; n?(Ua(n), n.animate({d:g})):d && g.length && (n = {stroke:c[1], "stroke-width":d, fill:"none", zIndex:1}, e?n.dashstyle = e:f && (n["stroke-linecap"] =
        n["stroke-linejoin"] = "round"), a[m] = a.chart.renderer.path(g).attr(n).add(a.group).shadow(!h && b.shadow))})}, clipNeg:function(){var a = this.options, b = this.chart, c = b.renderer, d = a.negativeColor || a.negativeFillColor, e, f = this.graph, g = this.area, h = this.posClip, k = this.negClip; e = b.chartWidth; var l = b.chartHeight, m = x(e, l), n = this.yAxis; d && (f || g) && (d = A(n.toPixels(a.threshold || 0, !0)), 0 > d && (m -= d), a = {x:0, y:0, width:m, height:d}, m = {x:0, y:d, width:m, height:m}, b.inverted && (a.height = m.y = b.plotWidth - d, c.isVML && (a = {x:b.plotWidth -
        d - b.plotLeft, y:0, width:e, height:l}, m = {x:d + b.plotLeft - e, y:0, width:b.plotLeft + d, height:e})), n.reversed?(b = m, e = a):(b = a, e = m), h?(h.animate(b), k.animate(e)):(this.posClip = h = c.clipRect(b), this.negClip = k = c.clipRect(e), f && this.graphNeg && (f.clip(h), this.graphNeg.clip(k)), g && (g.clip(h), this.areaNeg.clip(k))))}, invertGroups:function(){function a(){var a = {width:b.yAxis.len, height:b.xAxis.len}; t(["group", "markerGroup"], function(c){b[c] && b[c].attr(a).invert()})}var b = this, c = b.chart; b.xAxis && (J(c, "resize", a), J(b,
        "destroy", function(){P(c, "resize", a)}), a(), b.invertGroups = a)}, plotGroup:function(a, b, c, d, e){var f = this[a], g = !f; g && (this[a] = f = this.chart.renderer.g(b).attr({visibility:c, zIndex:d || .1}).add(e)); f[g?"attr":"animate"](this.getPlotBox()); return f}, getPlotBox:function(){var a = this.chart, b = this.xAxis, c = this.yAxis; a.inverted && (b = c, c = this.xAxis); return{translateX:b?b.left:a.plotLeft, translateY:c?c.top:a.plotTop, scaleX:1, scaleY:1}}, render:function(){var a = this, b = a.chart, c, d = a.options, e = (c = d.animation) && !!a.animate &&
        b.renderer.isSVG && r(c.duration, 500) || 0, f = a.visible?"visible":"hidden", g = d.zIndex, h = a.hasRendered, k = b.seriesGroup; c = a.plotGroup("group", "series", f, g, k); a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, k); e && a.animate(!0); a.getAttribs(); c.inverted = a.isCartesian?b.inverted:!1; a.drawGraph && (a.drawGraph(), a.clipNeg()); t(a.points, function(a){a.redraw && a.redraw()}); a.drawDataLabels && a.drawDataLabels(); a.visible && a.drawPoints(); a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker(); b.inverted &&
        a.invertGroups(); !1 === d.clip || a.sharedClipKey || h || c.clip(b.clipRect); e && a.animate(); h || (e?a.animationTimeout = setTimeout(function(){a.afterAnimate()}, e):a.afterAnimate()); a.isDirty = a.isDirtyData = !1; a.hasRendered = !0}, redraw:function(){var a = this.chart, b = this.isDirtyData, c = this.group, d = this.xAxis, e = this.yAxis; c && (a.inverted && c.attr({width:a.plotWidth, height:a.plotHeight}), c.animate({translateX:r(d && d.left, a.plotLeft), translateY:r(e && e.top, a.plotTop)})); this.translate(); this.setTooltipPoints && this.setTooltipPoints(!0);
        this.render(); b && z(this, "updatedData")}}; var Lb = Za(fa); K.line = Lb; sa.area = D(Gb, {threshold:0}); var Mb = Za(fa, {type:"area", getSegments:function(){var a = this, b = [], c = [], d = [], e = this.xAxis, f = this.yAxis, g = f.stacks[this.stackKey], h = {}, k, l, m = this.points, n = this.options.connectNulls, p, q; if (this.options.stacking && !this.cropped){for (p = 0; p < m.length; p++)h[m[p].x] = m[p]; for (q in g)null !== g[q].total && d.push( + q); d.sort(function(a, b){return a - b}); t(d, function(b){var d = 0, m; if (!n || h[b] && null !== h[b].y)if (h[b])c.push(h[b]);
        else{for (p = a.index; p <= f.series.length; p++)if (m = g[b].points[p + "," + b]){d = m[1]; break}k = e.translate(b); l = f.toPixels(d, !0); c.push({y:null, plotX:k, clientX:k, plotY:l, yBottom:l, onMouseOver:Ca})}}); c.length && b.push(c)} else fa.prototype.getSegments.call(this), b = this.segments; this.segments = b}, getSegmentPath:function(a){var b = fa.prototype.getSegmentPath.call(this, a), c = [].concat(b), d, e = this.options; d = b.length; var f = this.yAxis.getThreshold(e.threshold), g; 3 === d && c.push("L", b[1], b[2]); if (e.stacking && !this.closedStacks)for (d =
        a.length - 1; 0 <= d; d--)g = r(a[d].yBottom, f), d < a.length - 1 && e.step && c.push(a[d + 1].plotX, g), c.push(a[d].plotX, g); else this.closeSegment(c, a, f); this.areaPath = this.areaPath.concat(c); return b}, closeSegment:function(a, b, c){a.push("L", b[b.length - 1].plotX, c, "L", b[0].plotX, c)}, drawGraph:function(){this.areaPath = []; fa.prototype.drawGraph.apply(this); var a = this, b = this.areaPath, c = this.options, d = c.negativeColor, e = c.negativeFillColor, f = [["area", this.color, c.fillColor]]; (d || e) && f.push(["areaNeg", d, e]); t(f, function(d){var e =
        d[0], f = a[e]; f?f.animate({d:b}):a[e] = a.chart.renderer.path(b).attr({fill:r(d[2], oa(d[1]).setOpacity(r(c.fillOpacity, .75)).get()), zIndex:0}).add(a.group)})}, drawLegendSymbol:xb.drawRectangle}); K.area = Mb; var Wa = M.TrackerMixin = {drawTrackerPoint:function(){var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && {cursor:d}, f = function(c){var d = c.target, e; if (b.hoverSeries !== a)a.onMouseOver(); for (; d && !e; )e = d.point, d = d.parentNode; if (e !== w && e !== b.hoverPoint)e.onMouseOver(c)}; t(a.points, function(a){a.graphic &&
        (a.graphic.element.point = a); a.dataLabel && (a.dataLabel.element.point = a)}); a._hasTracking || (t(a.trackerGroups, function(b){if (a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function(a){c.onTrackerMouseOut(a)}).css(e), Ba))a[b].on("touchstart", f)}), a._hasTracking = !0)}, drawTrackerGraph:function(){var a = this, b = a.options, c = b.trackByArea, d = [].concat(c?a.areaPath:a.graphPath), e = d.length, f = a.chart, g = f.pointer, h = f.renderer, k = f.options.tooltip.snap, l = a.tracker, m = b.cursor, n = m && {cursor:m},
        m = a.singlePoints, p, q = function(){if (f.hoverSeries !== a)a.onMouseOver()}, r = "rgba(192,192,192," + (V?1E-4:.002) + ")"; if (e && !c)for (p = e + 1; p--; )"M" === d[p] && d.splice(p + 1, 0, d[p + 1] - k, d[p + 2], "L"), (p && "M" === d[p] || p === e) && d.splice(p, 0, "L", d[p - 2] + k, d[p - 1]); for (p = 0; p < m.length; p++)e = m[p], d.push("M", e.plotX - k, e.plotY, "L", e.plotX + k, e.plotY); l?l.attr({d:d}):(a.tracker = h.path(d).attr({"stroke-linejoin":"round", visibility:a.visible?"visible":"hidden", stroke:r, fill:c?r:"none", "stroke-width":b.lineWidth + (c?0:2 * k), zIndex:2}).add(a.group),
        t([a.tracker, a.markerGroup], function(a){a.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function(a){g.onTrackerMouseOut(a)}).css(n); if (Ba)a.on("touchstart", q)}))}}; K.column && (ColumnSeries.prototype.drawTracker = Wa.drawTrackerPoint); K.pie && (K.pie.prototype.drawTracker = Wa.drawTrackerPoint); K.scatter && (ScatterSeries.prototype.drawTracker = Wa.drawTrackerPoint); y(Va.prototype, {setItemEvents:function(a, b, c, d, e){var f = this; (c?b:a.legendGroup).on("mouseover", function(){a.setState("hover");
        b.css(f.options.itemHoverStyle)}).on("mouseout", function(){b.css(a.visible?d:e); a.setState()}).on("click", function(b){var c = function(){a.setVisible()}; b = {browserEvent:b}; a.firePointEvent?a.firePointEvent("legendItemClick", b, c):z(a, "legendItemClick", b, c)})}, createCheckboxForItem:function(a){a.checkbox = pa("input", {type:"checkbox", checked:a.selected, defaultChecked:a.selected}, this.options.itemCheckboxStyle, this.chart.container); J(a.checkbox, "click", function(b){z(a, "checkboxClick", {checked:b.target.checked},
        function(){a.select()})})}}); F.legend.itemStyle.cursor = "pointer"; y(Oa.prototype, {showResetZoom:function(){var a = this, b = F.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo?null:"plotBox"; this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function(){a.zoomOut()}, d, e && e.hover).attr({align:c.position.align, title:b.resetZoomTitle}).add().align(c.position, !1, f)}, zoomOut:function(){var a = this; z(a, "selection", {resetSelection:!0}, function(){a.zoom()})}, zoom:function(a){var b,
        c = this.pointer, d = !1, e; !a || a.resetSelection?t(this.axes, function(a){b = a.zoom()}):t(a.xAxis.concat(a.yAxis), function(a){var e = a.axis, h = e.isXAxis; if (c[h?"zoomX":"zoomY"] || c[h?"pinchX":"pinchY"])b = e.zoom(a.min, a.max), e.displayBtn && (d = !0)}); e = this.resetZoomButton; d && !e?this.showResetZoom():!d && ca(e) && (this.resetZoomButton = e.destroy()); b && this.redraw(r(this.options.chart.animation, a && a.animation, 100 > this.pointCount))}, pan:function(a, b){var c = this, d = c.hoverPoints, e; d && t(d, function(a){a.setState()}); t("xy" ===
        b?[1, 0]:[1], function(b){var d = a[b?"chartX":"chartY"], h = c[b?"xAxis":"yAxis"][0], k = c[b?"mouseDownX":"mouseDownY"], l = (h.pointRange || 0) / 2, m = h.getExtremes(), n = h.toValue(k - d, !0) + l, k = h.toValue(k + c[b?"plotWidth":"plotHeight"] - d, !0) - l; h.series.length && n > O(m.dataMin, m.min) && k < x(m.dataMax, m.max) && (h.setExtremes(n, k, !1, !1, {trigger:"pan"}), e = !0); c[b?"mouseDownX":"mouseDownY"] = d}); e && c.redraw(!1); S(c.container, {cursor:"move"})}}); y(Ha.prototype, {select:function(a, b){var c = this, d = c.series, e = d.chart; a = r(a, !c.selected);
        c.firePointEvent(a?"select":"unselect", {accumulate:b}, function(){c.selected = c.options.selected = a; d.options.data[Ta(c, d.data)] = c.options; c.setState(a && "select"); b || t(e.getSelectedPoints(), function(a){a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[Ta(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect"))})})}, onMouseOver:function(a){var b = this.series, c = b.chart, d = c.tooltip, e = c.hoverPoint; if (e && e !== this)e.onMouseOut(); this.firePointEvent("mouseOver"); !d || d.shared && !b.noSharedTooltip ||
        d.refresh(this, a); this.setState("hover"); c.hoverPoint = this}, onMouseOut:function(){var a = this.series.chart, b = a.hoverPoints; this.firePointEvent("mouseOut"); b && - 1 !== Ta(this, b) || (this.setState(), a.hoverPoint = null)}, importEvents:function(){if (!this.hasImportedEvents){var a = D(this.series.options.point, this.options).events, b; this.events = a; for (b in a)J(this, b, a[b]); this.hasImportedEvents = !0}}, setState:function(a, b){var c = this.plotX, d = this.plotY, e = this.series, f = e.options.states, g = sa[e.type].marker && e.options.marker,
        h = g && !g.enabled, k = g && g.states[a], l = k && !1 === k.enabled, m = e.stateMarkerGraphic, n = this.marker || {}, p = e.chart, q = e.halo, r; a = a || ""; r = this.pointAttr[a] || e.pointAttr[a]; if (!(a === this.state && !b || this.selected && "select" !== a || f[a] && !1 === f[a].enabled || a && (l || h && !1 === k.enabled) || a && n.states && n.states[a] && !1 === n.states[a].enabled)){if (this.graphic)g = g && this.graphic.symbolName && r.r, this.graphic.attr(D(r, g?{x:c - g, y:d - g, width:2 * g, height:2 * g}:{})), m && m.hide(); else{if (a && k)if (g = k.radius, n = n.symbol || e.symbol, m && m.currentSymbol !==
        n && (m = m.destroy()), m)m[b?"animate":"attr"]({x:c - g, y:d - g}); else n && (e.stateMarkerGraphic = m = p.renderer.symbol(n, c - g, d - g, 2 * g, 2 * g).attr(r).add(e.markerGroup), m.currentSymbol = n); if (m)m[a && p.isInsidePlot(c, d, p.inverted)?"show":"hide"]()}(c = f[a] && f[a].halo) && c.size?(q || (e.halo = q = p.renderer.path().add(e.seriesGroup)), q.attr(y({fill:oa(this.color || e.color).setOpacity(c.opacity).get()}, c.attributes))[b?"animate":"attr"]({d:this.haloPath(c.size)})):q && q.attr({d:[]}); this.state = a}}, haloPath:function(a){var b =
        this.series, c = b.chart, d = b.getPlotBox(), e = c.inverted; return c.renderer.symbols.circle(d.translateX + (e?b.yAxis.len - this.plotY:this.plotX) - a, d.translateY + (e?b.xAxis.len - this.plotX:this.plotY) - a, 2 * a, 2 * a)}}); y(fa.prototype, {onMouseOver:function(){var a = this.chart, b = a.hoverSeries; if (b && b !== this)b.onMouseOut(); this.options.events.mouseOver && z(this, "mouseOver"); this.setState("hover"); a.hoverSeries = this}, onMouseOut:function(){var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint; if (d)d.onMouseOut(); this &&
        a.events.mouseOut && z(this, "mouseOut"); !c || a.stickyTracking || c.shared && !this.noSharedTooltip || c.hide(); this.setState(); b.hoverSeries = null}, setState:function(a){var b = this.options, c = this.graph, d = this.graphNeg, e = b.states, b = b.lineWidth; a = a || ""; this.state !== a && (this.state = a, e[a] && !1 === e[a].enabled || (a && (b = e[a].lineWidth || b + (e[a].lineWidthPlus || 0)), c && !c.dashstyle && (a = {"stroke-width":b}, c.attr(a), d && d.attr(a))))}, setVisible:function(a, b){var c = this, d = c.chart, e = c.legendItem, f, g = d.options.chart.ignoreHiddenSeries,
        h = c.visible; f = (c.visible = a = c.userOptions.visible = a === w?!h:a)?"show":"hide"; t(["group", "dataLabelsGroup", "markerGroup", "tracker"], function(a){if (c[a])c[a][f]()}); if (d.hoverSeries === c)c.onMouseOut(); e && d.legend.colorizeItem(c, a); c.isDirty = !0; c.options.stacking && t(d.series, function(a){a.options.stacking && a.visible && (a.isDirty = !0)}); t(c.linkedSeries, function(b){b.setVisible(a, !1)}); g && (d.isDirtyBox = !0); !1 !== b && d.redraw(); z(c, f)}, setTooltipPoints:function(a){var b = [], c, d, e = this.xAxis, f = e && e.getExtremes(),
        g = e?e.tooltipLen || e.len:this.chart.plotSizeX, h, k, l = []; if (!1 !== this.options.enableMouseTracking && !this.singularTooltips){a && (this.tooltipPoints = null); t(this.segments || this.points, function(a){b = b.concat(a)}); e && e.reversed && (b = b.reverse()); this.orderTooltipPoints && this.orderTooltipPoints(b); a = b.length; for (k = 0; k < a; k++)if (e = b[k], c = e.x, c >= f.min && c <= f.max)for (h = b[k + 1], c = d === w?0:d + 1, d = b[k + 1]?O(x(0, W((e.clientX + (h?h.wrappedClientX || h.clientX:g)) / 2)), g):g; 0 <= c && c <= d; )l[c++] = e; this.tooltipPoints = l}}, show:function(){this.setVisible(!0)},
        hide:function(){this.setVisible(!1)}, select:function(a){this.selected = a = a === w?!this.selected:a; this.checkbox && (this.checkbox.checked = a); z(this, a?"select":"unselect")}, drawTracker:Wa.drawTrackerGraph}); y(ob.prototype, {init:function(a, b, c){var d = this, e = d.defaultOptions; d.chart = b; b.angular && (e.background = {}); d.options = a = D(e, a); (a = a.background) && t([].concat(Z(a)).reverse(), function(a){var b = a.backgroundColor, e = c.userOptions; a = D(d.defaultBackgroundOptions, a); b && (a.backgroundColor = b); a.color = a.backgroundColor;
        c.options.plotBands.unshift(a); e.plotBands = e.plotBands || []; e.plotBands.unshift(a)})}, defaultOptions:{center:["50%", "50%"], size:"85%", startAngle:0}, defaultBackgroundOptions:{shape:"circle", borderWidth:1, borderColor:"silver", backgroundColor:{linearGradient:{x1:0, y1:0, x2:0, y2:1}, stops:[[0, "#FFF"], [1, "#DDD"]]}, from: - Number.MAX_VALUE, innerRadius:0, to:Number.MAX_VALUE, outerRadius:"105%"}}); var Xa = za.prototype, fb = na.prototype, Nb = {getOffset:Ca, redraw:function(){this.isDirty = !1}, render:function(){this.isDirty =
        !1}, setScale:Ca, setCategories:Ca, setTitle:Ca}, yb = {isRadial:!0, defaultRadialGaugeOptions:{labels:{align:"center", x:0, y:null}, minorGridLineWidth:0, minorTickInterval:"auto", minorTickLength:10, minorTickPosition:"inside", minorTickWidth:1, tickLength:10, tickPosition:"inside", tickWidth:2, title:{rotation:0}, zIndex:2}, defaultRadialXOptions:{gridLineWidth:1, labels:{align:null, distance:15, x:0, y:null}, maxPadding:0, minPadding:0, showLastLabel:!1, tickLength:0}, defaultRadialYOptions:{gridLineInterpolation:"circle",
        labels:{align:"right", x: - 3, y: - 2}, showLastLabel:!1, title:{x:4, text:null, rotation:90}}, setOptions:function(a){a = this.options = D(this.defaultOptions, this.defaultRadialOptions, a); a.plotBands || (a.plotBands = [])}, getOffset:function(){Xa.getOffset.call(this); this.chart.axisOffset[this.side] = 0; this.center = this.pane.center = Kb.getCenter.call(this.pane)}, getLinePath:function(a, b){var c = this.center; b = r(b, c[2] / 2 - this.offset); return this.chart.renderer.symbols.arc(this.left + c[0], this.top + c[1], b, b, {start:this.startAngleRad,
        end:this.endAngleRad, open:!0, innerR:0})}, setAxisTranslation:function(){Xa.setAxisTranslation.call(this); this.center && (this.transA = this.isCircular?(this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1):this.center[2] / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis?this.transA * this.minPointOffset:0)}, beforeSetTickPositions:function(){this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0)}, setAxisSize:function(){Xa.setAxisSize.call(this); this.isRadial &&
        (this.center = this.pane.center = M.CenteredSeriesMixin.getCenter.call(this.pane), this.isCircular && (this.sector = this.endAngleRad - this.startAngleRad), this.len = this.width = this.height = this.center[2] * r(this.sector, 1) / 2)}, getPosition:function(a, b){return this.postTranslate(this.isCircular?this.translate(a):0, r(this.isCircular?b:this.translate(a), this.center[2] / 2) - this.offset)}, postTranslate:function(a, b){var c = this.chart, d = this.center; a = this.startAngleRad + a; return{x:c.plotLeft + d[0] + Math.cos(a) * b, y:c.plotTop +
        d[1] + Math.sin(a) * b}}, getPlotBandPath:function(a, b, c){var d = this.center, e = this.startAngleRad, f = d[2] / 2, g = [r(c.outerRadius, "100%"), c.innerRadius, r(c.thickness, 10)], h = /%$/, k, l = this.isCircular; "polygon" === this.options.gridLineInterpolation?d = this.getPlotLinePath(a).concat(this.getPlotLinePath(b, !0)):(a = Math.max(a, this.min), b = Math.min(b, this.max), l || (g[0] = this.translate(a), g[1] = this.translate(b)), g = Ea(g, function(a){h.test(a) && (a = E(a, 10) * f / 100); return a}), "circle" !== c.shape && l?(a = e + this.translate(a), b = e +
        this.translate(b)):(a = - Math.PI / 2, b = 1.5 * Math.PI, k = !0), d = this.chart.renderer.symbols.arc(this.left + d[0], this.top + d[1], g[0], g[0], {start:Math.min(a, b), end:Math.max(a, b), innerR:r(g[1], g[0] - g[2]), open:k})); return d}, getPlotLinePath:function(a, b){var c = this, d = c.center, e = c.chart, f = c.getPosition(a), g, h, k; c.isCircular?k = ["M", d[0] + e.plotLeft, d[1] + e.plotTop, "L", f.x, f.y]:"circle" === c.options.gridLineInterpolation?(a = c.translate(a)) && (k = c.getLinePath(0, a)):(t(e.xAxis, function(a){a.pane === c.pane && (g = a)}), k = [], a = c.translate(a), d = g.tickPositions, g.autoConnect && (d = d.concat([d[0]])), b && (d = [].concat(d).reverse()), t(d, function(b, c){h = g.getPosition(b, a); k.push(c?"L":"M", h.x, h.y)})); return k}, getTitlePosition:function(){var a = this.center, b = this.chart, c = this.options.title; return{x:b.plotLeft + a[0] + (c.x || 0), y:b.plotTop + a[1] - {high:.5, middle:.25, low:0}[c.align] * a[2] + (c.y || 0)}}}; M(Xa, "init", function(a, b, c){var d = b.angular, e = b.polar, f = c.isX, g = d && f, h, k; k = b.options; var l = c.pane || 0; if (d){if (w(this, g?Sb:Fb), h = !f)this.defaultRadialOptions =
        this.defaultRadialGaugeOptions} else e && (w(this, Fb), this.defaultRadialOptions = (h = f)?this.defaultRadialXOptions:F(this.defaultYAxisOptions, this.defaultRadialYOptions)); a.call(this, b, c); g || !d && !e || (a = this.options, b.panes || (b.panes = []), this.pane = l = b.panes[l] = b.panes[l] || new xb(ca(k.pane)[l], b, this), l = l.options, b.inverted = !1, k.chart.zoomType = null, this.startAngleRad = b = (l.startAngle - 90) * Math.PI / 180, this.endAngleRad = k = (r(l.endAngle, l.startAngle + 360) - 90) * Math.PI / 180, this.offset = a.offset || 0, (this.isCircular =
        h) && c.max === z && k - b === 2 * Math.PI && (this.autoConnect = !0))}); M(mb, "getPosition", function(a, b, c, d, e){var f = this.axis; return f.getPosition?f.getPosition(c):a.call(this, b, c, d, e)}); M(mb, "getLabelPosition", function(a, b, c, d, e, f, g, h, k){var l = this.axis, m = f.y, p = 20, n = f.align, q = (l.translate(this.pos) + l.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360; l.isRadial?(a = l.getPosition(this.pos, l.center[2] / 2 + r(f.distance, - 25)), "auto" === f.rotation?d.attr({rotation:q}):null === m && (m = l.chart.renderer.fontMetrics(d.styles.fontSize).b -
        d.getBBox().height / 2), null === n && (l.isCircular?(this.label.getBBox().width > l.len * l.tickInterval / (l.max - l.min) && (p = 0), n = q > p && q < 180 - p?"left":q > 180 + p && q < 360 - p?"right":"center"):n = "center", d.attr({align:n})), a.x += f.x, a.y += m):a = a.call(this, b, c, d, e, f, g, h, k); return a}); M(mb, "getMarkPath", function(a, b, c, d, e, f, g){var h = this.axis; h.isRadial?(a = h.getPosition(this.pos, h.center[2] / 2 + d), b = ["M", b, c, "L", a.x, a.y]):b = a.call(this, b, c, d, e, f, g); return b}); (function(){function a(a, b, c){a.call(this, b, c); this.chart.polar &&
        (this.closeSegment = function(a){var b = this.xAxis.center; a.push("L", b[0], b[1])}, this.closedStacks = !0)}function b(a, b){var c = this.chart, d = this.options.animation, e = this.group, m = this.markerGroup, p = this.xAxis.center, n = c.plotLeft, q = c.plotTop; c.polar?c.renderer.isSVG && (!0 === d && (d = {}), b?(c = {translateX:p[0] + n, translateY:p[1] + q, scaleX:.001, scaleY:.001}, e.attr(c), m && m.attr(c)):(c = {translateX:n, translateY:q, scaleX:1, scaleY:1}, e.animate(c, d), m && m.animate(c, d), this.animate = null)):a.call(this, b)}var c = X.prototype,
        d = kb.prototype, e; c.searchPointByAngle = function(a){var b = this.chart, c = this.xAxis.pane.center; return this.searchKDTree({clientX:180 + Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop) * ( - 180 / Math.PI)})}; M(c, "buildKDTree", function(a){this.chart.polar && (this.kdByAngle?this.searchPoint = this.searchPointByAngle:this.kdDimensions = 2); a.apply(this)}); c.toXY = function(a){var b, c = this.chart, d = a.plotX; b = a.plotY; a.rectPlotX = d; a.rectPlotY = b; b = this.xAxis.postTranslate(a.plotX, this.yAxis.len - b); a.plotX = a.polarPlotX =
        b.x - c.plotLeft; a.plotY = a.polarPlotY = b.y - c.plotTop; this.kdByAngle?(c = (d / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, 0 > c && (c += 360), a.clientX = c):a.clientX = a.plotX}; L.area && M(L.area.prototype, "init", a); L.areaspline && M(L.areaspline.prototype, "init", a); L.spline && M(L.spline.prototype, "getPointSpline", function(a, b, c, d){var e, m, p, n, q, r, t; this.chart.polar?(e = c.plotX, m = c.plotY, a = b[d - 1], p = b[d + 1], this.connectEnds && (a || (a = b[b.length - 2]), p || (p = b[1])), a && p && (n = a.plotX, q = a.plotY, b = p.plotX, r = p.plotY, n = (1.5 *
        e + n) / 2.5, q = (1.5 * m + q) / 2.5, p = (1.5 * e + b) / 2.5, t = (1.5 * m + r) / 2.5, b = Math.sqrt(Math.pow(n - e, 2) + Math.pow(q - m, 2)), r = Math.sqrt(Math.pow(p - e, 2) + Math.pow(t - m, 2)), n = Math.atan2(q - m, n - e), q = Math.atan2(t - m, p - e), t = Math.PI / 2 + (n + q) / 2, Math.abs(n - t) > Math.PI / 2 && (t -= Math.PI), n = e + Math.cos(t) * b, q = m + Math.sin(t) * b, p = e + Math.cos(Math.PI + t) * r, t = m + Math.sin(Math.PI + t) * r, c.rightContX = p, c.rightContY = t), d?(c = ["C", a.rightContX || a.plotX, a.rightContY || a.plotY, n || e, q || m, e, m], a.rightContX = a.rightContY = null):c = ["M", e, m]):c = a.call(this, b, c, d);
        return c}); M(c, "translate", function(a){var b = this.chart; a.call(this); if (b.polar && (this.kdByAngle = b.tooltip && b.tooltip.shared, !this.preventPostTranslate))for (a = this.points, b = a.length; b--; )this.toXY(a[b])}); M(c, "getSegmentPath", function(a, b){var c = this.points; this.chart.polar && !1 !== this.options.connectEnds && b[b.length - 1] === c[c.length - 1] && null !== c[0].y && (this.connectEnds = !0, b = [].concat(b, [c[0]])); return a.call(this, b)}); M(c, "animate", b); L.column && (e = L.column.prototype, M(e, "animate", b), M(e, "translate",
        function(a){var b = this.xAxis, c = this.yAxis.len, d = b.center, e = b.startAngleRad, m = this.chart.renderer, p, n; this.preventPostTranslate = !0; a.call(this); if (b.isRadial)for (b = this.points, n = b.length; n--; )p = b[n], a = p.barX + e, p.shapeType = "path", p.shapeArgs = {d:m.symbols.arc(d[0], d[1], c - p.plotY, null, {start:a, end:a + p.pointWidth, innerR:c - r(p.yBottom, c)})}, this.toXY(p), p.tooltipPos = [p.plotX, p.plotY], p.ttBelow = p.plotY > d[1]}), M(e, "alignDataLabel", function(a, b, d, e, l, m){this.chart.polar?(a = b.rectPlotX / Math.PI * 180, null === e.align &&
        (e.align = 20 < a && 160 > a?"left":200 < a && 340 > a?"right":"center"), null === e.verticalAlign && (e.verticalAlign = 45 > a || 315 < a?"bottom":135 < a && 225 > a?"top":"middle"), c.alignDataLabel.call(this, b, d, e, l, m)):a.call(this, b, d, e, l, m)})); M(d, "getCoordinates", function(a, b){var c = this.chart, d = {xAxis:[], yAxis:[]}; c.polar?t(c.axes, function(a){var e = a.isXAxis, f = a.center, n = b.chartX - f[0] - c.plotLeft, f = b.chartY - f[1] - c.plotTop; d[e?"xAxis":"yAxis"].push({axis:a, value:a.translate(e?Math.PI - Math.atan2(n, f):Math.sqrt(Math.pow(n, 2) + Math.pow(f,
        2)), !0)})}):d = a.call(this, b); return d})})(); w(D, {Color:ja, Point:La, Tick:sa, Renderer:Ba, SVGElement:T, SVGRenderer:Ba, arrayMin:Ma, arrayMax:xa, charts:Z, dateFormat:wa, error:da, format:ra, pathAnim:eb, getOptions:function(){return P}, hasBidiBug:Hb, isTouchDevice:Ab, setOptions:function(a){P = F(!0, P, a); ob(); return P}, addEvent:R, removeEvent:W, createElement:pa, discardElement:Na, css:N, each:t, map:Ja, merge:F, splat:ca, extendClass:Za, pInt:I, svg:aa, canvas:fa, vml:!aa && !fa, product:"Highcharts 4.1.8", version:"/Highstock 2.1.8"})})();